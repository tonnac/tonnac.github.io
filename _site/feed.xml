<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom" ><generator uri="https://jekyllrb.com/" version="4.2.0">Jekyll</generator><link href="https://tonnac.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="https://tonnac.github.io/" rel="alternate" type="text/html" /><updated>2021-05-22T19:15:41+00:00</updated><id>https://tonnac.github.io/feed.xml</id><title type="html">블로그</title><author><name>tonnac</name></author><entry><title type="html">[UE4] Jenkins 안드로이드 빌드</title><link href="https://tonnac.github.io/project/ue4/ci/drafts_UE4_Jenkins_Android/" rel="alternate" type="text/html" title="[UE4] Jenkins 안드로이드 빌드" /><published>2021-05-19T12:28:24+00:00</published><updated>2021-05-19T12:28:24+00:00</updated><id>https://tonnac.github.io/project/ue4/ci/drafts_UE4_Jenkins_Android</id><content type="html" xml:base="https://tonnac.github.io/project/ue4/ci/drafts_UE4_Jenkins_Android/">&lt;p&gt;인터넷 돌아다니다가 빌드 자동화에 대해 알게되고 Jenkins를 통해 언리얼엔진 프로젝트에 적용해 본 내용을 정리함&lt;/p&gt;

&lt;h1 id=&quot;1-jenkins-설치&quot;&gt;1. Jenkins 설치&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jenkins.io/download/&quot;&gt;Jenkins 다운로드 페이지&lt;/a&gt;&lt;br /&gt;
설치에 딱히 어려움은 없음.&lt;br /&gt;
추가적으로 Jenkins는 JRE 설치가 필요하다.&lt;br /&gt;
&lt;a href=&quot;https://java.com/ko/download/ie_manual.jsp?locale=ko&quot;&gt;Java 다운로드 페이지&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-환경설정&quot;&gt;2. 환경설정&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/J0.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
초기화면&lt;br /&gt;
Jenkins는 현재 사용중인 브라우저 언어에 따라서 설정이되는데, 한글같은 경우는 번역체가 좀 있어서 그냥 영어를 쓰는게 편한듯&lt;/p&gt;

&lt;h2 id=&quot;1-노드추가&quot;&gt;1) 노드추가&lt;/h2&gt;

&lt;p&gt;Manage Jenkins -&amp;gt; Manage Nodes and Clouds -&amp;gt; New Node로 추가해준다.&lt;br /&gt;
노드에 환경 변수를 추가해준다. ARCHIVE_ROOT는 빌드가 진행한 후 결과물을 압축해서 올릴 수 있는데 필요없다면 패스.
ENGINE_ROOT에 쓸 엔진을 추가해준다.&lt;br /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/J1.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-프로젝트-추가&quot;&gt;3. 프로젝트 추가&lt;/h1&gt;

&lt;p&gt;NewItem -&amp;gt; Freestyle project로 새로운 프로젝트를 생성한다.&lt;/p&gt;

&lt;h2 id=&quot;1-general&quot;&gt;1) General&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/J2.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-this-project-is-parameterized-선택&quot;&gt;1 This Project is parameterized (선택)&lt;/h3&gt;

&lt;p&gt;파라미터를 통해 다양하게 빌드를 진행할 수 있다.&lt;br /&gt;
위와같이 솔루션구성을 다르게 한다던가 플랫폼을 변경해서 빌드를 하는 등으로 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-restrict-where-this-project-can-be-run&quot;&gt;2 Restrict where this project can be run&lt;/h3&gt;

&lt;p&gt;앞서 만들었던 노드의 이름을 넣어준다.&lt;/p&gt;

&lt;h3 id=&quot;3-user-custom-workspace&quot;&gt;3 User custom workspace&lt;/h3&gt;

&lt;p&gt;프로젝트 폴더를 넣어준다.&lt;/p&gt;

&lt;h2 id=&quot;2-source-code-management&quot;&gt;2) Source Code Management&lt;/h2&gt;

&lt;p&gt;자신이 사용하고 있는 소스컨트롤을 선택하고 Repository를 설정&lt;/p&gt;

&lt;h2 id=&quot;3-build-triggers&quot;&gt;3) Build Triggers&lt;/h2&gt;

&lt;p&gt;빌드가 될 시점을 선택한다.&lt;br /&gt;
현재 테스트해본것은 Poll SCM으로 H/2 * * * * 값을 넣어줘서 2분마다 Repository를 확인해서 변경 사항이 있으면 빌드를 진행하는 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;4-build&quot;&gt;4) Build&lt;/h2&gt;

&lt;p&gt;빌드 명령을 설정해주는 부분.&lt;/p&gt;

&lt;p&gt;Add build step에서 Execute Windows batch command를 선택해서 추가해준다.&lt;/p&gt;

&lt;h3 id=&quot;1-temp-binaries-intermediate-폴더-삭제&quot;&gt;1 temp, Binaries, Intermediate 폴더 삭제&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rd /s /q temp
&lt;span class=&quot;nb&quot;&gt;rmdir&lt;/span&gt; /s /q &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;inaries&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;rmdir&lt;/span&gt; /s /q &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ntermediate&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;빌드한 파일들은 temp폴더에 저장했다가 빌드가 완료되면 폴더이름을 바꿔주어서 temp 폴더를 넣어준다.&lt;/p&gt;

&lt;h3 id=&quot;2-unrealbuildtool을-이용해서-uproject파일에서-sln파일-생성&quot;&gt;2 UnrealBuildTool을 이용해서 uproject파일에서 sln파일 생성&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%ENGINE_ROOT%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\E&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ngine&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;inaries&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;otNET&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nrealBuildTool.exe&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-projectfiles&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%.uproject&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-game&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rocket&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-progress&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-msbuild로-프로젝트-컴파일&quot;&gt;3 Msbuild로 프로젝트 컴파일&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;rogram Files (x86)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\M&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;icrosoft Visual Studio&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;019&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\C&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ommunity&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\M&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;SBuild&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\C&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;urrent&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\M&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;SBuild.exe&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%.sln&quot;&lt;/span&gt; /t:build /p:Configuration&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%BUILD_CONFIGURATION%&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Platform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Win64&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;verbosity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;diagnostic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MSBuild 파일 경로는 사용하는 컴퓨터 환경에서 찾아서 넣어주면 된다.&lt;/p&gt;

&lt;h3 id=&quot;4-temp폴더-없으면-생성&quot;&gt;4 temp폴더 없으면 생성&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;not exist &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%/temp/x64&quot;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%/temp/x64&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-패키징-진행&quot;&gt;5 패키징 진행&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%ENGINE_ROOT%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\E&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ngine&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;uild&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;atchFiles&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\R&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;unUAT.bat&quot;&lt;/span&gt; BuildCookRun &lt;span class=&quot;nt&quot;&gt;-project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%.uproject&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-noP4&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-platform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Win64 &lt;span class=&quot;nt&quot;&gt;-clientconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;%BUILD_CONFIGURATION% &lt;span class=&quot;nt&quot;&gt;-cook&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-allmaps&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-build&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-stage&lt;/span&gt; %USE_PAK% &lt;span class=&quot;nt&quot;&gt;-archive&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-archivedirectory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%/temp/x64&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-temp폴더-이름-변경&quot;&gt;6 Temp폴더 이름 변경&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ren %WORKSPACE%&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;emp&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\W&lt;/span&gt;indowsNoEditor %PROJECT_NAME%_%BUILD_CONFIGURATION%_x64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-완료한-빌드폴더-압축하기선택&quot;&gt;7 완료한 빌드폴더 압축하기(선택)&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%ARCHIVE_ROOT%/7z.exe&quot;&lt;/span&gt; a &lt;span class=&quot;nt&quot;&gt;-t7z&lt;/span&gt; %WORKSPACE%/temp/x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64.7z &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%_%BUILD_CONFIGURATION%_x64&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;5-post-build-actions&quot;&gt;5) Post-build Actions&lt;/h2&gt;

&lt;p&gt;빌드가 끝나고 나서 할것들을 정할 수 있다.&lt;br /&gt;
슬랙에 알람, 이메일 전송, Jenkins에 압축한 파일 올리기 등등이 가능.&lt;/p&gt;

&lt;h1 id=&quot;todo&quot;&gt;TODO&lt;/h1&gt;

&lt;p&gt;현재 테스트 환경은 로컬에서 진행한것이라 추후에 서버컴퓨터에서 작동을 시켜보기&lt;br /&gt;
안드로이드로 빌드를하면 중간에 에러가 나서 이 부분을 어떻게 해야할지 생각해보기&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cairansteverink.nl/cairansteverink/blog/unreal-engine-4-build-automation-with-jenkins-and-perforce/&quot;&gt;https://www.cairansteverink.nl/cairansteverink/blog/unreal-engine-4-build-automation-with-jenkins-and-perforce/&lt;/a&gt;
&lt;a href=&quot;https://patricevignola.com/post/automation-jenkins-unreal&quot;&gt;https://patricevignola.com/post/automation-jenkins-unreal&lt;/a&gt;
&lt;a href=&quot;https://github.com/skymapgames/jenkins-ue4&quot;&gt;https://github.com/skymapgames/jenkins-ue4&lt;/a&gt;&lt;/p&gt;</content><author><name>tonnac</name></author><category term="Project" /><category term="UE4" /><category term="CI" /><category term="Jenkins" /><summary type="html">인터넷 돌아다니다가 빌드 자동화에 대해 알게되고 Jenkins를 통해 언리얼엔진 프로젝트에 적용해 본 내용을 정리함 1. Jenkins 설치 Jenkins 다운로드 페이지 설치에 딱히 어려움은 없음. 추가적으로 Jenkins는 JRE 설치가 필요하다. Java 다운로드 페이지 2. 환경설정 초기화면 Jenkins는 현재 사용중인 브라우저 언어에 따라서 설정이되는데, 한글같은 경우는 번역체가 좀 있어서 그냥 영어를 쓰는게 편한듯 1) 노드추가 Manage Jenkins -&amp;gt; Manage Nodes and Clouds -&amp;gt; New Node로 추가해준다. 노드에 환경 변수를 추가해준다. ARCHIVE_ROOT는 빌드가 진행한 후 결과물을 압축해서 올릴 수 있는데 필요없다면 패스. ENGINE_ROOT에 쓸 엔진을 추가해준다. 3. 프로젝트 추가 NewItem -&amp;gt; Freestyle project로 새로운 프로젝트를 생성한다. 1) General 1 This Project is parameterized (선택) 파라미터를 통해 다양하게 빌드를 진행할 수 있다. 위와같이 솔루션구성을 다르게 한다던가 플랫폼을 변경해서 빌드를 하는 등으로 사용할 수 있다. 2 Restrict where this project can be run 앞서 만들었던 노드의 이름을 넣어준다. 3 User custom workspace 프로젝트 폴더를 넣어준다. 2) Source Code Management 자신이 사용하고 있는 소스컨트롤을 선택하고 Repository를 설정 3) Build Triggers 빌드가 될 시점을 선택한다. 현재 테스트해본것은 Poll SCM으로 H/2 * * * * 값을 넣어줘서 2분마다 Repository를 확인해서 변경 사항이 있으면 빌드를 진행하는 방식이다. 4) Build 빌드 명령을 설정해주는 부분. Add build step에서 Execute Windows batch command를 선택해서 추가해준다. 1 temp, Binaries, Intermediate 폴더 삭제 rd /s /q temp rmdir /s /q &quot;%WORKSPACE%\Binaries&quot; rmdir /s /q &quot;%WORKSPACE%\Intermediate&quot; 빌드한 파일들은 temp폴더에 저장했다가 빌드가 완료되면 폴더이름을 바꿔주어서 temp 폴더를 넣어준다. 2 UnrealBuildTool을 이용해서 uproject파일에서 sln파일 생성 &quot;%ENGINE_ROOT%\Engine\Binaries\DotNET\UnrealBuildTool.exe&quot; -projectfiles -project=&quot;%WORKSPACE%\%PROJECT_NAME%.uproject&quot; -game -rocket -progress 3 Msbuild로 프로젝트 컴파일 &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\MSBuild.exe&quot; &quot;%WORKSPACE%\%PROJECT_NAME%.sln&quot; /t:build /p:Configuration=&quot;%BUILD_CONFIGURATION%&quot;;Platform=Win64;verbosity=diagnostic MSBuild 파일 경로는 사용하는 컴퓨터 환경에서 찾아서 넣어주면 된다. 4 temp폴더 없으면 생성 if not exist &quot;%WORKSPACE%/temp/x64&quot; mkdir &quot;%WORKSPACE%/temp/x64&quot; 5 패키징 진행 &quot;%ENGINE_ROOT%\Engine\Build\BatchFiles\RunUAT.bat&quot; BuildCookRun -project=&quot;%WORKSPACE%\%PROJECT_NAME%.uproject&quot; -noP4 -platform=Win64 -clientconfig=%BUILD_CONFIGURATION% -cook -allmaps -build -stage %USE_PAK% -archive -archivedirectory=&quot;%WORKSPACE%/temp/x64&quot; 6 Temp폴더 이름 변경 ren %WORKSPACE%\temp\x64\WindowsNoEditor %PROJECT_NAME%_%BUILD_CONFIGURATION%_x64 7 완료한 빌드폴더 압축하기(선택) &quot;%ARCHIVE_ROOT%/7z.exe&quot; a -t7z %WORKSPACE%/temp/x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64.7z &quot;%WORKSPACE%\temp\x64\%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64&quot; 5) Post-build Actions 빌드가 끝나고 나서 할것들을 정할 수 있다. 슬랙에 알람, 이메일 전송, Jenkins에 압축한 파일 올리기 등등이 가능. TODO 현재 테스트 환경은 로컬에서 진행한것이라 추후에 서버컴퓨터에서 작동을 시켜보기 안드로이드로 빌드를하면 중간에 에러가 나서 이 부분을 어떻게 해야할지 생각해보기 참고 https://www.cairansteverink.nl/cairansteverink/blog/unreal-engine-4-build-automation-with-jenkins-and-perforce/ https://patricevignola.com/post/automation-jenkins-unreal https://github.com/skymapgames/jenkins-ue4</summary></entry><entry><title type="html">[UE4] Jenkins를 이용한 CI환경 구축</title><link href="https://tonnac.github.io/project/ue4/ci/UE4_Jenkins/" rel="alternate" type="text/html" title="[UE4] Jenkins를 이용한 CI환경 구축" /><published>2021-05-16T00:00:00+00:00</published><updated>2021-05-16T00:00:00+00:00</updated><id>https://tonnac.github.io/project/ue4/ci/UE4_Jenkins</id><content type="html" xml:base="https://tonnac.github.io/project/ue4/ci/UE4_Jenkins/">&lt;p&gt;인터넷 돌아다니다가 빌드 자동화에 대해 알게되고 Jenkins를 통해 언리얼엔진 프로젝트에 적용해 본 내용을 정리함&lt;/p&gt;

&lt;h1 id=&quot;1-jenkins-설치&quot;&gt;1. Jenkins 설치&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.jenkins.io/download/&quot;&gt;Jenkins 다운로드 페이지&lt;/a&gt;&lt;br /&gt;
설치에 딱히 어려움은 없음.&lt;br /&gt;
추가적으로 Jenkins는 JRE 설치가 필요하다.&lt;br /&gt;
&lt;a href=&quot;https://java.com/ko/download/ie_manual.jsp?locale=ko&quot;&gt;Java 다운로드 페이지&lt;/a&gt;&lt;/p&gt;

&lt;h1 id=&quot;2-환경설정&quot;&gt;2. 환경설정&lt;/h1&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/J0.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
초기화면&lt;br /&gt;
Jenkins는 현재 사용중인 브라우저 언어에 따라서 설정이되는데, 한글같은 경우는 번역체가 좀 있어서 그냥 영어를 쓰는게 편한듯&lt;/p&gt;

&lt;h2 id=&quot;1-노드추가&quot;&gt;1) 노드추가&lt;/h2&gt;

&lt;p&gt;Manage Jenkins -&amp;gt; Manage Nodes and Clouds -&amp;gt; New Node로 추가해준다.&lt;br /&gt;
노드에 환경 변수를 추가해준다. ARCHIVE_ROOT는 빌드가 진행한 후 결과물을 압축해서 올릴 수 있는데 필요없다면 패스.
ENGINE_ROOT에 쓸 엔진을 추가해준다.&lt;br /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/J1.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h1 id=&quot;3-프로젝트-추가&quot;&gt;3. 프로젝트 추가&lt;/h1&gt;

&lt;p&gt;NewItem -&amp;gt; Freestyle project로 새로운 프로젝트를 생성한다.&lt;/p&gt;

&lt;h2 id=&quot;1-general&quot;&gt;1) General&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/J2.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;1-this-project-is-parameterized-선택&quot;&gt;1 This Project is parameterized (선택)&lt;/h3&gt;

&lt;p&gt;파라미터를 통해 다양하게 빌드를 진행할 수 있다.&lt;br /&gt;
위와같이 솔루션구성을 다르게 한다던가 플랫폼을 변경해서 빌드를 하는 등으로 사용할 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;2-restrict-where-this-project-can-be-run&quot;&gt;2 Restrict where this project can be run&lt;/h3&gt;

&lt;p&gt;앞서 만들었던 노드의 이름을 넣어준다.&lt;/p&gt;

&lt;h3 id=&quot;3-user-custom-workspace&quot;&gt;3 User custom workspace&lt;/h3&gt;

&lt;p&gt;프로젝트 폴더를 넣어준다.&lt;/p&gt;

&lt;h2 id=&quot;2-source-code-management&quot;&gt;2) Source Code Management&lt;/h2&gt;

&lt;p&gt;자신이 사용하고 있는 소스컨트롤을 선택하고 Repository를 설정&lt;/p&gt;

&lt;h2 id=&quot;3-build-triggers&quot;&gt;3) Build Triggers&lt;/h2&gt;

&lt;p&gt;빌드가 될 시점을 선택한다.&lt;br /&gt;
현재 테스트해본것은 Poll SCM으로 H/2 * * * * 값을 넣어줘서 2분마다 Repository를 확인해서 변경 사항이 있으면 빌드를 진행하는 방식이다.&lt;/p&gt;

&lt;h2 id=&quot;4-build&quot;&gt;4) Build&lt;/h2&gt;

&lt;p&gt;빌드 명령을 설정해주는 부분.&lt;/p&gt;

&lt;p&gt;Add build step에서 Execute Windows batch command를 선택해서 추가해준다.&lt;/p&gt;

&lt;h3 id=&quot;1-temp-binaries-intermediate-폴더-삭제&quot;&gt;1 temp, Binaries, Intermediate 폴더 삭제&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;rd /s /q temp
&lt;span class=&quot;nb&quot;&gt;rmdir&lt;/span&gt; /s /q &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;inaries&quot;&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;rmdir&lt;/span&gt; /s /q &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\I&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ntermediate&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;빌드한 파일들은 temp폴더에 저장했다가 빌드가 완료되면 폴더이름을 바꿔주어서 temp 폴더를 넣어준다.&lt;/p&gt;

&lt;h3 id=&quot;2-unrealbuildtool을-이용해서-uproject파일에서-sln파일-생성&quot;&gt;2 UnrealBuildTool을 이용해서 uproject파일에서 sln파일 생성&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%ENGINE_ROOT%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\E&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ngine&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;inaries&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\D&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;otNET&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\U&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;nrealBuildTool.exe&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-projectfiles&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%.uproject&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-game&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-rocket&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-progress&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-msbuild로-프로젝트-컴파일&quot;&gt;3 Msbuild로 프로젝트 컴파일&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;C:&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\P&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;rogram Files (x86)&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\M&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;icrosoft Visual Studio&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\2&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;019&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\C&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ommunity&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\M&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;SBuild&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\C&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;urrent&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;in&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\M&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;SBuild.exe&quot;&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%.sln&quot;&lt;/span&gt; /t:build /p:Configuration&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%BUILD_CONFIGURATION%&quot;&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;Platform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Win64&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;verbosity&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;diagnostic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;MSBuild 파일 경로는 사용하는 컴퓨터 환경에서 찾아서 넣어주면 된다.&lt;/p&gt;

&lt;h3 id=&quot;4-temp폴더-없으면-생성&quot;&gt;4 temp폴더 없으면 생성&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;if &lt;/span&gt;not exist &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%/temp/x64&quot;&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;mkdir&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%/temp/x64&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-패키징-진행&quot;&gt;5 패키징 진행&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%ENGINE_ROOT%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\E&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;ngine&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;uild&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\B&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;atchFiles&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\R&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;unUAT.bat&quot;&lt;/span&gt; BuildCookRun &lt;span class=&quot;nt&quot;&gt;-project&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%.uproject&quot;&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-noP4&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-platform&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Win64 &lt;span class=&quot;nt&quot;&gt;-clientconfig&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;%BUILD_CONFIGURATION% &lt;span class=&quot;nt&quot;&gt;-cook&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-allmaps&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-build&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-stage&lt;/span&gt; %USE_PAK% &lt;span class=&quot;nt&quot;&gt;-archive&lt;/span&gt; &lt;span class=&quot;nt&quot;&gt;-archivedirectory&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%/temp/x64&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;6-temp폴더-이름-변경&quot;&gt;6 Temp폴더 이름 변경&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;ren %WORKSPACE%&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;emp&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;64&lt;span class=&quot;se&quot;&gt;\W&lt;/span&gt;indowsNoEditor %PROJECT_NAME%_%BUILD_CONFIGURATION%_x64
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;7-완료한-빌드폴더-압축하기선택&quot;&gt;7 완료한 빌드폴더 압축하기(선택)&lt;/h3&gt;

&lt;div class=&quot;language-sh highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;s2&quot;&gt;&quot;%ARCHIVE_ROOT%/7z.exe&quot;&lt;/span&gt; a &lt;span class=&quot;nt&quot;&gt;-t7z&lt;/span&gt; %WORKSPACE%/temp/x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64.7z &lt;span class=&quot;s2&quot;&gt;&quot;%WORKSPACE%&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\t&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;emp&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\x&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;64&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\%&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;PROJECT_NAME%_%BUILD_CONFIGURATION%_x64&quot;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;5-post-build-actions&quot;&gt;5) Post-build Actions&lt;/h2&gt;

&lt;p&gt;빌드가 끝나고 나서 할것들을 정할 수 있다.&lt;br /&gt;
슬랙에 알람, 이메일 전송, Jenkins에 압축한 파일 올리기 등등이 가능.&lt;/p&gt;

&lt;h1 id=&quot;todo&quot;&gt;TODO&lt;/h1&gt;

&lt;p&gt;현재 테스트 환경은 로컬에서 진행한것이라 추후에 서버컴퓨터에서 작동을 시켜보기&lt;br /&gt;
안드로이드로 빌드를하면 중간에 에러가 나서 이 부분을 어떻게 해야할지 생각해보기&lt;/p&gt;

&lt;h1 id=&quot;참고&quot;&gt;참고&lt;/h1&gt;

&lt;p&gt;&lt;a href=&quot;https://www.cairansteverink.nl/cairansteverink/blog/unreal-engine-4-build-automation-with-jenkins-and-perforce/&quot;&gt;https://www.cairansteverink.nl/cairansteverink/blog/unreal-engine-4-build-automation-with-jenkins-and-perforce/&lt;/a&gt;
&lt;a href=&quot;https://patricevignola.com/post/automation-jenkins-unreal&quot;&gt;https://patricevignola.com/post/automation-jenkins-unreal&lt;/a&gt;
&lt;a href=&quot;https://github.com/skymapgames/jenkins-ue4&quot;&gt;https://github.com/skymapgames/jenkins-ue4&lt;/a&gt;&lt;/p&gt;</content><author><name>tonnac</name></author><category term="Project" /><category term="UE4" /><category term="CI" /><category term="Jenkins" /><summary type="html">인터넷 돌아다니다가 빌드 자동화에 대해 알게되고 Jenkins를 통해 언리얼엔진 프로젝트에 적용해 본 내용을 정리함 1. Jenkins 설치 Jenkins 다운로드 페이지 설치에 딱히 어려움은 없음. 추가적으로 Jenkins는 JRE 설치가 필요하다. Java 다운로드 페이지 2. 환경설정 초기화면 Jenkins는 현재 사용중인 브라우저 언어에 따라서 설정이되는데, 한글같은 경우는 번역체가 좀 있어서 그냥 영어를 쓰는게 편한듯 1) 노드추가 Manage Jenkins -&amp;gt; Manage Nodes and Clouds -&amp;gt; New Node로 추가해준다. 노드에 환경 변수를 추가해준다. ARCHIVE_ROOT는 빌드가 진행한 후 결과물을 압축해서 올릴 수 있는데 필요없다면 패스. ENGINE_ROOT에 쓸 엔진을 추가해준다. 3. 프로젝트 추가 NewItem -&amp;gt; Freestyle project로 새로운 프로젝트를 생성한다. 1) General 1 This Project is parameterized (선택) 파라미터를 통해 다양하게 빌드를 진행할 수 있다. 위와같이 솔루션구성을 다르게 한다던가 플랫폼을 변경해서 빌드를 하는 등으로 사용할 수 있다. 2 Restrict where this project can be run 앞서 만들었던 노드의 이름을 넣어준다. 3 User custom workspace 프로젝트 폴더를 넣어준다. 2) Source Code Management 자신이 사용하고 있는 소스컨트롤을 선택하고 Repository를 설정 3) Build Triggers 빌드가 될 시점을 선택한다. 현재 테스트해본것은 Poll SCM으로 H/2 * * * * 값을 넣어줘서 2분마다 Repository를 확인해서 변경 사항이 있으면 빌드를 진행하는 방식이다. 4) Build 빌드 명령을 설정해주는 부분. Add build step에서 Execute Windows batch command를 선택해서 추가해준다. 1 temp, Binaries, Intermediate 폴더 삭제 rd /s /q temp rmdir /s /q &quot;%WORKSPACE%\Binaries&quot; rmdir /s /q &quot;%WORKSPACE%\Intermediate&quot; 빌드한 파일들은 temp폴더에 저장했다가 빌드가 완료되면 폴더이름을 바꿔주어서 temp 폴더를 넣어준다. 2 UnrealBuildTool을 이용해서 uproject파일에서 sln파일 생성 &quot;%ENGINE_ROOT%\Engine\Binaries\DotNET\UnrealBuildTool.exe&quot; -projectfiles -project=&quot;%WORKSPACE%\%PROJECT_NAME%.uproject&quot; -game -rocket -progress 3 Msbuild로 프로젝트 컴파일 &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\MSBuild\Current\Bin\MSBuild.exe&quot; &quot;%WORKSPACE%\%PROJECT_NAME%.sln&quot; /t:build /p:Configuration=&quot;%BUILD_CONFIGURATION%&quot;;Platform=Win64;verbosity=diagnostic MSBuild 파일 경로는 사용하는 컴퓨터 환경에서 찾아서 넣어주면 된다. 4 temp폴더 없으면 생성 if not exist &quot;%WORKSPACE%/temp/x64&quot; mkdir &quot;%WORKSPACE%/temp/x64&quot; 5 패키징 진행 &quot;%ENGINE_ROOT%\Engine\Build\BatchFiles\RunUAT.bat&quot; BuildCookRun -project=&quot;%WORKSPACE%\%PROJECT_NAME%.uproject&quot; -noP4 -platform=Win64 -clientconfig=%BUILD_CONFIGURATION% -cook -allmaps -build -stage %USE_PAK% -archive -archivedirectory=&quot;%WORKSPACE%/temp/x64&quot; 6 Temp폴더 이름 변경 ren %WORKSPACE%\temp\x64\WindowsNoEditor %PROJECT_NAME%_%BUILD_CONFIGURATION%_x64 7 완료한 빌드폴더 압축하기(선택) &quot;%ARCHIVE_ROOT%/7z.exe&quot; a -t7z %WORKSPACE%/temp/x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64/%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64.7z &quot;%WORKSPACE%\temp\x64\%PROJECT_NAME%_%BUILD_CONFIGURATION%_x64&quot; 5) Post-build Actions 빌드가 끝나고 나서 할것들을 정할 수 있다. 슬랙에 알람, 이메일 전송, Jenkins에 압축한 파일 올리기 등등이 가능. TODO 현재 테스트 환경은 로컬에서 진행한것이라 추후에 서버컴퓨터에서 작동을 시켜보기 안드로이드로 빌드를하면 중간에 에러가 나서 이 부분을 어떻게 해야할지 생각해보기 참고 https://www.cairansteverink.nl/cairansteverink/blog/unreal-engine-4-build-automation-with-jenkins-and-perforce/ https://patricevignola.com/post/automation-jenkins-unreal https://github.com/skymapgames/jenkins-ue4</summary></entry><entry><title type="html">[Modern Effective C++] 2. auto의 타입 추론 규칙을 숙지</title><link href="https://tonnac.github.io/book/02/" rel="alternate" type="text/html" title="[Modern Effective C++] 2. auto의 타입 추론 규칙을 숙지" /><published>2021-03-01T00:00:00+00:00</published><updated>2021-03-01T00:00:00+00:00</updated><id>https://tonnac.github.io/book/02</id><content type="html" xml:base="https://tonnac.github.io/book/02/">&lt;h1 id=&quot;auto-추론-방식&quot;&gt;auto 추론 방식&lt;/h1&gt;

&lt;p&gt;auto의 타입추론은 &lt;a href=&quot;/book/01/&quot;&gt;[1. 템플릿 타입 추론 규칙을 숙지]&lt;/a&gt;에서와 같이 템플릿 타입 추론과 거의 같다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ParamType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;auto에서 타입 추론이 이뤄질 때, auto는 템플릿의 T와 동일한 역할을 하며, 변수의 형식 지정자(type specifier)는 ParamType과 동일한 역할을 한다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func_for_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// x의 타입 추론을 위한 개념적인 템플릿&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func_for_x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func_for_cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// cx의 타입 추론을 위한 개념적인 템플릿&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func_for_cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;func_for_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// rx의 타입 추론을 위한 개념적인 템플릿&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;func_for_rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;템플릿 타입 추론과 마찬가지로 auto의 타입 추론 또한 변수의 형식 지정자에 따라 세가지 경우로 나뉜다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우&lt;/li&gt;
  &lt;li&gt;ParamType이 Universal Reference인 경우&lt;/li&gt;
  &lt;li&gt;ParamType이 포인터도 아니고 참조도 아닌 경우&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// 경우 3&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 경우 3&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 경우 1&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//경우 2&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uref1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// x는 int이고 왼값, uref1의 타입은 int&amp;amp;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uref2&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// cx는 const int이고 왼값, uref1의 타입은 const int&amp;amp;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;uref3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 27은 int이고 오른값, uref3은 int&amp;amp;&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;배열과 함수 이름이 포인터로 붕괴는 방식은 auto 또한 동일하다.&lt;/p&gt;

&lt;h1 id=&quot;템플릿-타입-추론과-차이점&quot;&gt;템플릿 타입 추론과 차이점&lt;/h1&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x1&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;         &lt;span class=&quot;c1&quot;&gt;// 타입은 int, 값은 27&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;x2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// 위와 동일&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x3&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 형식은 std::initializer_list&amp;lt;int&amp;gt;, 값은 { 27 }&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x4&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 타입은 int, 값은 27&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;auto는 = 다음에 오는 변수의 초기치가 중괄호 쌍으로 감싸인 형태로 오면 타입 추론은 std::initializer_list로 한다.&lt;br /&gt;
그러나 템플릿 함수 인자에 중괄호 초기치를 전달하면 타입 추론이 실패해서 컴파일이 되지않는다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// x의 형식은 std::initializer_list&amp;lt;int&amp;gt;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// 오류 T에 대한 타입 추론을 할 수 없음&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;initializer_list&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;initList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;11&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;23&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;9&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;            &lt;span class=&quot;c1&quot;&gt;// 이건 가능, T는 int로 추론되며, initList는 std::initializer_list&amp;lt;int&amp;gt;로 추론&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;C++14에서는 함수의 반환 형식을 auto로 지정해서 추론하게 할 수 있으며, 람다의 매개변수에도 auto를 사용이 가능하다.&lt;br /&gt;
그러나 이러한 용법은 템플릿 타입 추론이 적용되서 중괄호 초기치를 반환하는 함수는 텀파일이 실패한다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;createInitList&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;()&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;{&lt;/span&gt;
  &lt;span class=&quot;k&quot;&gt;return&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 오류 {1,2,3} 타입 추론할 수 없음&lt;/span&gt;
&lt;span class=&quot;p&quot;&gt;}&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;std&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;::&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;vector&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;gt;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;resetV&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;v&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;](&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;auto&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;{&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;v&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;newValue&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;p&quot;&gt;};&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// C++14&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;resetV&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;({&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;3&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;});&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 오류 {1,2,3} 타입 추론할 수 없음&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;결론&quot;&gt;결론&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;auto 타입 추론은 대체로 템플릿 타입 추론과 같지만, 중괄호 초기치에선 다르다.&lt;/li&gt;
  &lt;li&gt;함수의 반환 형식이나 람다 매개변수에 쓰인 auto는 템플릿 타입 추론이 적용된다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>tonnac</name></author><category term="Book" /><category term="Modern Effective C++" /><category term="C++" /><category term="Modern C++" /><category term="Type Deduction" /><summary type="html">auto 추론 방식 auto의 타입추론은 [1. 템플릿 타입 추론 규칙을 숙지]에서와 같이 템플릿 타입 추론과 거의 같다. template &amp;lt;typename T&amp;gt; void f(ParamType param); auto에서 타입 추론이 이뤄질 때, auto는 템플릿의 T와 동일한 역할을 하며, 변수의 형식 지정자(type specifier)는 ParamType과 동일한 역할을 한다. auto x = 27; const auto cx = x; const auto&amp;amp; rx = x; template &amp;lt;typename T&amp;gt; void func_for_x(T param); // x의 타입 추론을 위한 개념적인 템플릿 func_for_x(27); template &amp;lt;typename T&amp;gt; void func_for_cx(const T param); // cx의 타입 추론을 위한 개념적인 템플릿 func_for_cx(x); template &amp;lt;typename T&amp;gt; void func_for_rx(const T&amp;amp; param); // rx의 타입 추론을 위한 개념적인 템플릿 func_for_rx(x); 템플릿 타입 추론과 마찬가지로 auto의 타입 추론 또한 변수의 형식 지정자에 따라 세가지 경우로 나뉜다. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우 ParamType이 Universal Reference인 경우 ParamType이 포인터도 아니고 참조도 아닌 경우 auto x = 27; // 경우 3 const auto cx = x; // 경우 3 const auto&amp;amp; rx = x; // 경우 1 //경우 2 auto&amp;amp;&amp;amp; uref1 = x; // x는 int이고 왼값, uref1의 타입은 int&amp;amp; auto&amp;amp;&amp;amp; uref2 = cx; // cx는 const int이고 왼값, uref1의 타입은 const int&amp;amp; auto&amp;amp;&amp;amp; uref3 = 27; // 27은 int이고 오른값, uref3은 int&amp;amp;&amp;amp; 배열과 함수 이름이 포인터로 붕괴는 방식은 auto 또한 동일하다. 템플릿 타입 추론과 차이점 auto x1 = 27; // 타입은 int, 값은 27 auto x2(27); // 위와 동일 auto x3 = { 27 }; // 형식은 std::initializer_list&amp;lt;int&amp;gt;, 값은 { 27 } auto x4{ 27 }; // 타입은 int, 값은 27 auto는 = 다음에 오는 변수의 초기치가 중괄호 쌍으로 감싸인 형태로 오면 타입 추론은 std::initializer_list로 한다. 그러나 템플릿 함수 인자에 중괄호 초기치를 전달하면 타입 추론이 실패해서 컴파일이 되지않는다. auto x = { 11, 23, 9 }; // x의 형식은 std::initializer_list&amp;lt;int&amp;gt; template&amp;lt;typename T&amp;gt; void f(T param); f({ 11, 23, 9}); // 오류 T에 대한 타입 추론을 할 수 없음 template&amp;lt;typename T&amp;gt; void f(std::initializer_list&amp;lt;T&amp;gt; initList); f({ 11, 23, 9}); // 이건 가능, T는 int로 추론되며, initList는 std::initializer_list&amp;lt;int&amp;gt;로 추론 C++14에서는 함수의 반환 형식을 auto로 지정해서 추론하게 할 수 있으며, 람다의 매개변수에도 auto를 사용이 가능하다. 그러나 이러한 용법은 템플릿 타입 추론이 적용되서 중괄호 초기치를 반환하는 함수는 텀파일이 실패한다. auto createInitList() { return { 1, 2, 3 }; // 오류 {1,2,3} 타입 추론할 수 없음 } std::vector&amp;lt;int&amp;gt; v; auto resetV = [&amp;amp;v](const auto&amp;amp; newValue) { v = newValue; }; // C++14 resetV({1,2,3}); // 오류 {1,2,3} 타입 추론할 수 없음 결론 auto 타입 추론은 대체로 템플릿 타입 추론과 같지만, 중괄호 초기치에선 다르다. 함수의 반환 형식이나 람다 매개변수에 쓰인 auto는 템플릿 타입 추론이 적용된다.</summary></entry><entry><title type="html">[Modern Effective C++] 1. 템플릿 타입 추론 규칙을 숙지</title><link href="https://tonnac.github.io/book/01/" rel="alternate" type="text/html" title="[Modern Effective C++] 1. 템플릿 타입 추론 규칙을 숙지" /><published>2021-03-01T00:00:00+00:00</published><updated>2021-03-01T00:00:00+00:00</updated><id>https://tonnac.github.io/book/01</id><content type="html" xml:base="https://tonnac.github.io/book/01/">&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ParamType&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;expr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;위와같은 템플릿 함수를 호출할때 컴파일러는 expr을 이용해 T 와 ParamType을 추론한다.&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;T에대해 추론된 형식은 항상 expr의 형식이 되지 않는다. expr의 형식외에도 ParamType의 형태에도 의존하기 때문. ParamType형태에 따라 세 가지 경우로 나뉜다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ParamType이 Universal Reference인 경우&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;ParamType이 포인터도 아니고 참조도 아닌 경우&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h1 id=&quot;템플릿-추론-방식&quot;&gt;템플릿 추론 방식&lt;/h1&gt;

&lt;h2 id=&quot;1-paramtype이-포인터-또는-참조-형식이지만-universal-reference는-아닌-경우&quot;&gt;1. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우&lt;/h2&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// param은 참조 형식&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;   &lt;span class=&quot;c1&quot;&gt;// const int&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// const int&amp;amp;&lt;/span&gt;

&lt;span class=&quot;c1&quot;&gt;//위의 변수들로 f 호출결과&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// T는 int, param은 int&amp;amp;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// T는 const int, param은 const int&amp;amp;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// T는 const int, param은 const int&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;이를 통해 알수있는것은&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;객체의 const성은 T에 대해 추론된 타입의 일부가 된다.&lt;/li&gt;
  &lt;li&gt;타입 추론 과정에서 참조성은 무시가된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;2-paramtype이-universal-reference인-경우&quot;&gt;2. ParamType이 Universal Reference인 경우&lt;/h2&gt;

&lt;p&gt;템플릿이 Universal Reference 매개변수를 받는 경우에 매개변수의 선언은 오른값 참조와 같은 모습이지만, 왼값 인수가 전달되면 다른 방식으로 행동한다.&lt;/p&gt;

&lt;!-- TODO 24 Universal Reference 추가 --&gt;
&lt;!-- TODO 28 Universal Reference 추가 --&gt;

&lt;ul&gt;
  &lt;li&gt;expr이 왼값이면, T 와 ParamType 둘 다 왼값 참조로 추론된다.&lt;/li&gt;
  &lt;li&gt;expr이 오른값이면, 1번과같이 ‘정상적인’ 규칙들이 적용&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;      &lt;span class=&quot;c1&quot;&gt;// param은 Universal Reference&lt;/span&gt;

&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 이전과 동일&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 이전과 동일&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 이전과 동일&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;// x는 왼값 T와 param의 형식 모두 int&amp;amp;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// cx는 왼값 T와 param의 형식 모두 const int&amp;amp;&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// rx는 왼값 T와 param의 형식 모두 const int&amp;amp;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// 27은 오른값 T는 int, param 타입은 int&amp;amp;&amp;amp;&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;Universal Reference가 관여하면 왼값 인수와 오른값 인수에 대해 서로 다른 타입추론이 적용된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;3-paramtype이-포인터도-아니고-참조도-아닌-경우&quot;&gt;3. ParamType이 포인터도 아니고 참조도 아닌 경우&lt;/h2&gt;

&lt;p&gt;인수가 값으로 전달되는 경우다.&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;param은 인수의 복사본으로 새로운 객체이다. 따라서 expr에서 T가 추론되는 과정에서 다음 규칙들이 적용된다.&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;expr이 참조형식이면, 이전처럼 참조 부분은 무시된다.&lt;/li&gt;
  &lt;li&gt;expr이 참조를 무시하고, expr이 const이면 그 const 역시 무시한다. volatile역시 무시된다.&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;27&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;;&lt;/span&gt;             &lt;span class=&quot;c1&quot;&gt;// 이전과 동일&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 이전과 동일&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;       &lt;span class=&quot;c1&quot;&gt;// 이전과 동일&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;x&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                   &lt;span class=&quot;c1&quot;&gt;// T와 param의 형식 모두 int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;cx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// T와 param의 형식 모두 int&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;rx&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;                  &lt;span class=&quot;c1&quot;&gt;// T와 param의 형식 모두 int&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;param은 cx나 rx의 복사본이므로, const가 아니게된다.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// ptr은 const 객체를 가리키는 const 포인터&lt;/span&gt;
  &lt;span class=&quot;s&quot;&gt;&quot;Fun with pointers&quot;&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;ptr&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;ptr은 다른 변수의 주소값을 가리키도록 변경할 수 없으며, 문자열 또한 변경이 불가능하다.&lt;br /&gt;
ptr을 f에 전달하면 &lt;strong&gt;포인터 자체는 값으로 전달&lt;/strong&gt;된다. 그래서 값 전달 방식의 타입추론과 같은 규칙으로 적용된다.&lt;br /&gt;
결과적으로 param 타입은 const char*가 되어서 const 문자열을 가리키는 수정 가능한 포인터가 된다.&lt;/p&gt;

&lt;h1 id=&quot;배열-인수&quot;&gt;배열 인수&lt;/h1&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&quot;J. P. Briggs&quot;&lt;/span&gt;  &lt;span class=&quot;c1&quot;&gt;// name의 타입은 const char[13]&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;const&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;char&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;ptrToName&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;        &lt;span class=&quot;c1&quot;&gt;// 배열이 포인터로 붕괴된다.&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;    &lt;span class=&quot;c1&quot;&gt;// 값 전달 매개변수가 있는 템플릿&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;템플릿 함수에 값으로 전달되는 배열의 형식은 포인터로 추론된다. 즉 T는 const char*로 추론된다.&lt;br /&gt;
함수의 매개변수를 배열로 선언 할 수는 없지만, &lt;strong&gt;&lt;em&gt;배열에 대한 참조로 선언할 수는 있다.&lt;/em&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;     &lt;span class=&quot;c1&quot;&gt;// 참조 전달 매개변수가 있는 템플릿&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;f&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;              &lt;span class=&quot;c1&quot;&gt;// 배열을 f에 전달&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;param타입을 바꿔서 호출하면 T에 대해 추론된 형식은 배열의 실제 형식이된다.&lt;br /&gt;
이 예에서는 T는 const char [13]이 되고 param의 타입은 const char (&amp;amp;)[13]이 된다.&lt;/p&gt;

&lt;h1 id=&quot;함수-인수&quot;&gt;함수 인수&lt;/h1&gt;

&lt;div class=&quot;language-cpp highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;,&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;double&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt; &lt;span class=&quot;c1&quot;&gt;// someFunc는 함수;&lt;/span&gt;
                            &lt;span class=&quot;c1&quot;&gt;// 형식은 void(int, double)&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;           &lt;span class=&quot;c1&quot;&gt;// f1의 param은 값 전달 방식&lt;/span&gt;

&lt;span class=&quot;k&quot;&gt;template&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;typename&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;&amp;gt;&lt;/span&gt;
&lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;T&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;amp;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;param&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;          &lt;span class=&quot;c1&quot;&gt;// f2의 param은 값 전달 방식&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f1&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// param은 함수 포인터로 추론됨&lt;/span&gt;
                            &lt;span class=&quot;c1&quot;&gt;// 형식은 void(*)(int, double)&lt;/span&gt;

&lt;span class=&quot;n&quot;&gt;f2&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;someFunc&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;);&lt;/span&gt;               &lt;span class=&quot;c1&quot;&gt;// param은 함수 참조로 추론됨&lt;/span&gt;
                            &lt;span class=&quot;c1&quot;&gt;// 형식은 void (&amp;amp;)(int, double)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h1 id=&quot;결론&quot;&gt;결론&lt;/h1&gt;

&lt;ul&gt;
  &lt;li&gt;템플릿 타입 추론 도중 참조 형식의 인수들은 참조성이 무시된다.
&lt;!-- TODO 24연결 --&gt;&lt;/li&gt;
  &lt;li&gt;Universal Reference에 대한 타입 추론 과정에서 왼값 인수들은 특별하게 취급된다.&lt;/li&gt;
  &lt;li&gt;값 전달 방식의 매개변수에 대한 타입 추론 과정에서 const 또는 volatile은 제거된다.&lt;/li&gt;
  &lt;li&gt;타입 추론 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다.&lt;br /&gt;
단, 인수가 초기화하는 데 쓰이는 경우에는 포인터로 붕괴 하지 않는다.&lt;/li&gt;
&lt;/ul&gt;</content><author><name>tonnac</name></author><category term="Book" /><category term="Modern Effective C++" /><category term="C++" /><category term="Modern C++" /><category term="Type Deduction" /><summary type="html">template &amp;lt;typename T&amp;gt; void f(ParamType param); f(expr); 위와같은 템플릿 함수를 호출할때 컴파일러는 expr을 이용해 T 와 ParamType을 추론한다. T에대해 추론된 형식은 항상 expr의 형식이 되지 않는다. expr의 형식외에도 ParamType의 형태에도 의존하기 때문. ParamType형태에 따라 세 가지 경우로 나뉜다. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우 ParamType이 Universal Reference인 경우 ParamType이 포인터도 아니고 참조도 아닌 경우 템플릿 추론 방식 1. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우 template &amp;lt;typename T&amp;gt; void f(T&amp;amp; param); // param은 참조 형식 int x = 27 // int const int cx = x; // const int const int&amp;amp; rx = x; // const int&amp;amp; //위의 변수들로 f 호출결과 f(x); // T는 int, param은 int&amp;amp; f(cx); // T는 const int, param은 const int&amp;amp; f(rx); // T는 const int, param은 const int&amp;amp; 이를 통해 알수있는것은 객체의 const성은 T에 대해 추론된 타입의 일부가 된다. 타입 추론 과정에서 참조성은 무시가된다. 2. ParamType이 Universal Reference인 경우 템플릿이 Universal Reference 매개변수를 받는 경우에 매개변수의 선언은 오른값 참조와 같은 모습이지만, 왼값 인수가 전달되면 다른 방식으로 행동한다. expr이 왼값이면, T 와 ParamType 둘 다 왼값 참조로 추론된다. expr이 오른값이면, 1번과같이 ‘정상적인’ 규칙들이 적용 template &amp;lt;typename T&amp;gt; void f(T&amp;amp;&amp;amp; param); // param은 Universal Reference int x = 27; // 이전과 동일 const int cx = x // 이전과 동일 const int&amp;amp; rx = x // 이전과 동일 f(x); // x는 왼값 T와 param의 형식 모두 int&amp;amp; f(cx); // cx는 왼값 T와 param의 형식 모두 const int&amp;amp; f(rx); // rx는 왼값 T와 param의 형식 모두 const int&amp;amp; f(27); // 27은 오른값 T는 int, param 타입은 int&amp;amp;&amp;amp; Universal Reference가 관여하면 왼값 인수와 오른값 인수에 대해 서로 다른 타입추론이 적용된다. 3. ParamType이 포인터도 아니고 참조도 아닌 경우 인수가 값으로 전달되는 경우다. template &amp;lt;typename T&amp;gt; void f(T param); param은 인수의 복사본으로 새로운 객체이다. 따라서 expr에서 T가 추론되는 과정에서 다음 규칙들이 적용된다. expr이 참조형식이면, 이전처럼 참조 부분은 무시된다. expr이 참조를 무시하고, expr이 const이면 그 const 역시 무시한다. volatile역시 무시된다. int x = 27; // 이전과 동일 const int cx = x // 이전과 동일 const int&amp;amp; rx = x // 이전과 동일 f(x); // T와 param의 형식 모두 int f(cx); // T와 param의 형식 모두 int f(rx); // T와 param의 형식 모두 int param은 cx나 rx의 복사본이므로, const가 아니게된다. const char* const ptr = // ptr은 const 객체를 가리키는 const 포인터 &quot;Fun with pointers&quot; f(ptr); ptr은 다른 변수의 주소값을 가리키도록 변경할 수 없으며, 문자열 또한 변경이 불가능하다. ptr을 f에 전달하면 포인터 자체는 값으로 전달된다. 그래서 값 전달 방식의 타입추론과 같은 규칙으로 적용된다. 결과적으로 param 타입은 const char*가 되어서 const 문자열을 가리키는 수정 가능한 포인터가 된다. 배열 인수 const char name[] = &quot;J. P. Briggs&quot; // name의 타입은 const char[13] const char* ptrToName = name // 배열이 포인터로 붕괴된다. template&amp;lt;typename T&amp;gt; void f(T param); // 값 전달 매개변수가 있는 템플릿 f(name); 템플릿 함수에 값으로 전달되는 배열의 형식은 포인터로 추론된다. 즉 T는 const char*로 추론된다. 함수의 매개변수를 배열로 선언 할 수는 없지만, 배열에 대한 참조로 선언할 수는 있다. template&amp;lt;typename T&amp;gt; void f(T&amp;amp; param); // 참조 전달 매개변수가 있는 템플릿 f(name); // 배열을 f에 전달 param타입을 바꿔서 호출하면 T에 대해 추론된 형식은 배열의 실제 형식이된다. 이 예에서는 T는 const char [13]이 되고 param의 타입은 const char (&amp;amp;)[13]이 된다. 함수 인수 void someFunc(int, double); // someFunc는 함수; // 형식은 void(int, double) template&amp;lt;typename T&amp;gt; void f1(T param); // f1의 param은 값 전달 방식 template&amp;lt;typename T&amp;gt; void f1(T&amp;amp; param); // f2의 param은 값 전달 방식 f1(someFunc); // param은 함수 포인터로 추론됨 // 형식은 void(*)(int, double) f2(someFunc); // param은 함수 참조로 추론됨 // 형식은 void (&amp;amp;)(int, double) 결론 템플릿 타입 추론 도중 참조 형식의 인수들은 참조성이 무시된다. Universal Reference에 대한 타입 추론 과정에서 왼값 인수들은 특별하게 취급된다. 값 전달 방식의 매개변수에 대한 타입 추론 과정에서 const 또는 volatile은 제거된다. 타입 추론 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다. 단, 인수가 초기화하는 데 쓰이는 경우에는 포인터로 붕괴 하지 않는다.</summary></entry><entry><title type="html">[UE4] UE4를 이용한 WoW모작</title><link href="https://tonnac.github.io/project/ue4/UE4.Wow/" rel="alternate" type="text/html" title="[UE4] UE4를 이용한 WoW모작" /><published>2021-02-14T00:00:00+00:00</published><updated>2021-02-14T00:00:00+00:00</updated><id>https://tonnac.github.io/project/ue4/UE4.Wow</id><content type="html" xml:base="https://tonnac.github.io/project/ue4/UE4.Wow/">&lt;h1 id=&quot;1-게임의-개요&quot;&gt;1. 게임의 개요&lt;/h1&gt;

&lt;!-- Courtesy of embedresponsively.com //--&gt;

&lt;div class=&quot;responsive-video-container&quot;&gt;
    &lt;iframe src=&quot;https://www.youtube-nocookie.com/embed/Ln0s9rjYkuo&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
  &lt;/div&gt;

&lt;p&gt;게임: WoW 모작&lt;br /&gt;
인원: 개인&lt;br /&gt;
기간: 3주&lt;br /&gt;&lt;br /&gt;
엔진버전: 4.21&lt;/p&gt;

&lt;p&gt;C++ 70%, 블루프린트 30%로 작업&lt;/p&gt;

&lt;h1 id=&quot;2-개발내용&quot;&gt;2. 개발내용&lt;/h1&gt;

&lt;p&gt;캐릭터 애니매이션 블루프린트 구현&lt;br /&gt;
Behaviour Tree를 통해 AI 행동구현&lt;br /&gt;
캐릭터 레벨, 1차 스탯(힘, 민첩, 지능, 체력) 2차 스탯(가속, 치명타), 버프 구현&lt;br /&gt;
주문 시스템 구현&lt;br /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/UE4_04.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-1] 주문은 데이터에셋을 통해서 관리&lt;br /&gt;
Post-Processing을 통해 NPC 적대관계별 아웃라인 표시&lt;br /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/UE4_00.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/UE4_01.png&quot; alt=&quot;&quot; /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/UE4_02.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-2,3,4] NPC아웃라인&lt;/p&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/UE4_03.png&quot; alt=&quot;&quot; /&gt;
[그림 2-5] 구현된 UI&lt;br /&gt;
캐릭터 현재 상태&lt;br /&gt;
시전바 구현&lt;br /&gt;
주문책, 하단 행동단축바 주문책에서 드래그 앤 드롭으로 행동단축바로 등록하는 방식&lt;/p&gt;</content><author><name>tonnac</name></author><category term="Project" /><category term="UE4" /><category term="Wow" /><summary type="html">1. 게임의 개요 게임: WoW 모작 인원: 개인 기간: 3주 엔진버전: 4.21 C++ 70%, 블루프린트 30%로 작업 2. 개발내용 캐릭터 애니매이션 블루프린트 구현 Behaviour Tree를 통해 AI 행동구현 캐릭터 레벨, 1차 스탯(힘, 민첩, 지능, 체력) 2차 스탯(가속, 치명타), 버프 구현 주문 시스템 구현 [그림 2-1] 주문은 데이터에셋을 통해서 관리 Post-Processing을 통해 NPC 적대관계별 아웃라인 표시 [그림 2-2,3,4] NPC아웃라인 UI [그림 2-5] 구현된 UI 캐릭터 현재 상태 시전바 구현 주문책, 하단 행동단축바 주문책에서 드래그 앤 드롭으로 행동단축바로 등록하는 방식</summary></entry><entry><title type="html">[DirectX 11] Dx11를 이용한 모모도라 모작</title><link href="https://tonnac.github.io/project/directx11/DxMomo/" rel="alternate" type="text/html" title="[DirectX 11] Dx11를 이용한 모모도라 모작" /><published>2021-02-13T00:00:00+00:00</published><updated>2021-02-13T00:00:00+00:00</updated><id>https://tonnac.github.io/project/directx11/DxMomo</id><content type="html" xml:base="https://tonnac.github.io/project/directx11/DxMomo/">&lt;h1 id=&quot;1-게임의-개요&quot;&gt;1. 게임의 개요&lt;/h1&gt;

&lt;!-- Courtesy of embedresponsively.com //--&gt;

&lt;div class=&quot;responsive-video-container&quot;&gt;
    &lt;iframe src=&quot;https://www.youtube-nocookie.com/embed/zoIrgVcugQM&quot; frameborder=&quot;0&quot; webkitallowfullscreen=&quot;&quot; mozallowfullscreen=&quot;&quot; allowfullscreen=&quot;&quot;&gt;&lt;/iframe&gt;
  &lt;/div&gt;

&lt;p&gt;게임: 모모도라: 달 아래의 진혼곡 모작 DirectX 11 컨버팅&lt;br /&gt;
인원: 개인&lt;br /&gt;
기간: 3주&lt;br /&gt;&lt;/p&gt;

&lt;!-- [실행파일다운](https://tonnac.github.io/assets/MomodoraDx.7z) --&gt;

&lt;h1 id=&quot;2-게임-시스템&quot;&gt;2. 게임 시스템&lt;/h1&gt;

&lt;h2 id=&quot;core-와-sample-클래스&quot;&gt;Core 와 Sample 클래스&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_00.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-1] : Core 와 Sample의 클래스 다이어그램&lt;br /&gt;
Device는 DirectX를 사용하기 위해 기본적인 장치들을 생성하는 클래스로, 이를 윈도우를 띄우는 wClass가 상속하는 구조로 되어있다.
이를 다시 Core 클래스가 상속하는데, Core에서는 게임에 사용되는 전반적인 클래스들을 초기화 한다. Filepath 클래스는 게임에 쓰이는 리소스들의 경로를 저장하는데 쓰이는데, 함수와 멤버 모두 정적으로 구성되어있다.
SpriteMgr와 FSMMgr는 각각 Sprite 와 FSM을 초기에 데이터를 저장하여 필요할 때 불러올 수 있도록 구성하였다.
DirectWrite는 화면에 문자를 출력하기 위한 클래스인데, 현재는 FPS와 게임시간 SPF를 출력하는 용도로만 사용하고 있다.
Timer는 게임의 시간에 관련된 부분들을 계산하는 클래스로, 위에서 말한 FPS와 게임시간 SPF를 Timer에서 계산을 한다. Sound는 게임에서 쓰는 사운드들을 출력하기 위한 클래스로 게임내에서 배경음과 효과음을 따로 조절하기 위해 채널과 사운드를 배경과 효과음 따로 나눠서 저장하고 있다.
DirectInput은 키의 입력을 받아 처리하는 클래스인데, 키의 입력을 홀드상태와 업상태를 구분하기 위해서 현재의 키 상태와 이전 프레임의 키 상태를 저장한다.
Frame을 호출한 뒤에 코어에 마지막에 PostFrame을 호출해서 현재 상태를 이전 상태에 저장하는 방식이다.
Sample은 이 Core를 상속하는 클래스로, 내부에서 SceneMgr 프레임과 렌더를 호출해서 게임이 진행이 된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_01.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-2] : Core의 시퀀스 다이어그램 &lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;scenemgr와-scene-클래스&quot;&gt;SceneMgr와 Scene 클래스&lt;/h2&gt;

&lt;p&gt;SceneMgr는 Scene을 멤버로 둬서 현재의 Scene의 Frame과 Render를 호출한다. Scene의 전환이 일어나면 현재의 Scene을 Release한 뒤, getScene함수를 통해서 바뀌는 Scene을 생성해서 다시 Frame과 Render를 호출한다.
Scene은 생성을 할 때, 오브젝트들을 생성해서 배치 한 뒤, ObjectMgr에 추가하여 ObjectMgr의 Frame과 Render를 호출한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_02.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-3] : Scene과 SceneMgr의 클래스 다이어그램&lt;br /&gt;
게임 진행중에 지나온 Scene도 다시 돌아갈 수 있게끔, GameScene은 추가적으로 InverseInit 함수를 재정의하게 하여, 플레이어가 뒤 Scene에서 앞 Scene으로 올 때에는 오브젝트를 반대로 배치할 수 있도록 하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_03.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-4] : Scene과 SceneMgr의 시퀀스 다이어그램&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;shader와-texture-클래스&quot;&gt;Shader와 Texture 클래스&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_04.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-5] : Shader와 Texture의 클래스 다이어그램&lt;br /&gt;
Shader와 Texture는 모두 매니저 클래스를 통해 관리하며, 매니저의 Load함수를 호출하면 우선 사용자가 원하는 데이터가 캐시에 있는지 확인을 한다. 있으면 바로 그 데이터를 반환하고, 없을 경우는 전체 데이터를 통해서 똑같은 작업을 한다. 전체데이터에도 없으면 만들어서 반환하는 구조로 되어있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_05.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-6] : ShaderMgr과 TextureMgr의 시퀀스 다이어그램&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;objectmgr과-object-클래스&quot;&gt;ObjectMgr과 Object 클래스&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_06.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-7] : ObjectMgr과 Object의 클래스 다이어그램&lt;br /&gt;
Basic_Object는 오브젝트 생성시에 필요한 기본적인 버퍼 등을 가지고 있는 클래스로, Object는 이 Basic_Object를 멤버로 가진다. Object는 상수 버퍼를 사용하기위한 구조체와 정점들을 STL 벡터에 보관하며 충돌체크를 위한 충돌크기와 센터위치 값을 가진다. Plane_Object는 정점 4개로 사각형을 출력하기 위한 클래스로 이를 위해 정점의 인덱스들을 벡터에 저장하게 하였다. ObjectMgr은 오브젝트들을 관리하기 위한 클래스로 Plane_Object를 상속받는 클래스별로 따로 관리를 한다. ObjectMgr엔 컨테이너를 순회하며 Frame과 Render를 호출하는 함수가 템플릿으로 정의를 해서, 각각 컨테이너별로 따로 Frame과 Render를 호출한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_07.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-8] : ObjectMgr의 시퀀스 다이어그램&lt;br /&gt;&lt;/p&gt;

&lt;h3 id=&quot;effect클래스&quot;&gt;Effect클래스&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_08.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-9] : Effect의 클래스 다이어그램&lt;br /&gt;
PlayerEffect는 플레이어의 공격에 관련된 이펙트가 있다. 근접공격 3단계와 공중 공격, 화살이펙트가 이 클래스를 상속한다. Misc는 플레이어의 버프효과를 나타내기 위한 클래스로 MiscSet은 이 Misc클래스를 배열로 둬서 하나의 세트를 구성한다. 현재 구현되 있는 아이템인 수정꽃을 사용하면 플레이어의 주위에 4개의 이펙트가 돌아다니게 되는데, 이를 통해 버프의 지속시간을 확인할 수 있게하였다.&lt;/p&gt;

&lt;h3 id=&quot;character-클래스&quot;&gt;Character 클래스&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_09.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-10] : Character의 클래스 다이어그램&lt;br /&gt;
Character는 State 클래스와 함께 사용이 된다. State클래스는 캐릭터의 상태를 구현하는 클래스로 캐릭터의 이동이나 점프 공격 등 모든 상태를 구현하고 그 상태를 통해서 행동을 제약하는 방식으로 구성이 돼있다. Character는 자신의 모든 상태를 STL map에 저장하고 있다. State와 Character는 상호 참조 가능한 형태로, 만약 현재 상태에서 다른 상태로의 변화가 발생하면 State는 Character의 setState로 현재의 상태를 변경 시키고, Character는 해당하는 상태로 현재상태를 바꾸고 계속해서 Frame과 Render를 호출하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_10.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-11] : Character의 시퀀스 다이어그램&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;state&quot;&gt;State&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_11.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-12]: State의 클래스 다이어그램&lt;br /&gt;
State는 EnemyState와 PlayerState로 나뉘어져있다.&lt;/p&gt;

&lt;h3 id=&quot;playerstate&quot;&gt;PlayerState&lt;/h3&gt;

&lt;p&gt;플레이어의 상태는 키보드 입력키에 의해 변하게 된다.
방향키로 이동을 하고 A키로 점프, S키로 근접공격, D키로 활공격을 할 수 있다. 실제 원작 게임에선 플레이어의 상태가 42개가 구현되어 있으나, 현재까지는 22개의 상태가 구현이 되어있다.&lt;/p&gt;

&lt;h3 id=&quot;enemystate&quot;&gt;EnemyState&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_12.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-13]: EnemyState의 클래스 다이어그램&lt;br /&gt;
키보드로 상태가 변하는 플레이어와 달리 적 같은 경우는 상태별로 이벤트 발생 시 변경될 상태가 정의되어 있는 FSM이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_13.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-14]: 스크립트로 저장한 FSM&lt;br /&gt;
적들은 생성시에 FSMMgr을 통해서 하나의 FSM을 받아서 그 FSM에 맞게 행동을 한다. 이벤트가 발생하면 FinateStateMachine의 StateTransition 함수를 호출해서 반환되는 상태값으로 변경이 되는 방식이다. 그림 2-18을 예로들어서 현재 적이 Move 상태 일 때 플레이어를 발견해서 FINDTARGET이 발생하면 플레이어를 추적하는 Chase 상태가 된다.
현재 게임에서 구현 되어있는 FSM은 한 종류로 다음과 같다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_18.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_14.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-15] : 몬스터 FSM&lt;br /&gt;&lt;/p&gt;

&lt;h2 id=&quot;ui&quot;&gt;UI&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_15.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-16] : UI의 클래스 다이어그램&lt;br /&gt;
UI는 기본 구성요소들과 그 기본 구성요소들을 합하여 하나의 완성된 UI인 Menu 클래스 두 종류로 나눌 수 있다.&lt;/p&gt;

&lt;h3 id=&quot;lobbymenu&quot;&gt;LobbyMenu&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_16.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-17] : LobbyMenu&lt;br /&gt;
로비 메뉴는 6개의 Bar와 1개의 Select Bar로 이루어져 있다. 방향키 위, 아래 버튼을 누르면 활성화된 슬롯이 바뀌는 방식으로 작동한다.&lt;/p&gt;

&lt;h3 id=&quot;setting&quot;&gt;Setting&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_17.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-18] : 설정 화면&lt;br /&gt;
설정화면은 3개의 Bar와 1개의 SelectBar 그리고 2개의 ProgressBar로 이루어져 있다. 로비와 마찬가지로 위, 아래 키로 슬롯을 이동할 수 있으며, 추가적으로 효과음과 음악에 커서가 위치하면 화살표 좌, 우 키를 통해 볼륨을 조절할 수 있는데, 줄이게 되면 오른쪽에 바가 작아지고 키우게 되면 바가 커지는 형식으로 만들어져 있다.&lt;/p&gt;

&lt;h3 id=&quot;gameui&quot;&gt;GameUI&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_18.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-19] : GameUI&lt;br /&gt;
GameUI는 3개의 Bar와 1개의 ProgressBar와 한 개의 ItemSlot, 4개의 폰트로 제작하였다.
GameUI는 게임이 진행되는 동안 항상 왼쪽 위 모서리에 고정된 상태로 출력이 되며, 왼쪽 끝에 있는 아이템 슬롯은 현재 퀵슬롯에 등록된 아이템의 아이콘과 해당 아이템의 개수를 보여준다. 또한 퀵슬롯에 다른 아이템이 등록되어 있다면, E키를 통해서 언제든지 다음 아이템으로 전환할 수도 있다. HP바는 플레이어의 HP가 최대치일때는 그림과 같이 바가 가득 찬 상태로 있고, HP가 줄어들면 바의 크기도 같이 줄어들게 된다.
그 아래의 숫자 3개는 게임상 화폐를 보여주는 UI인데, 현재까지는 구현은 되어있지 않다.&lt;/p&gt;

&lt;h3 id=&quot;ingamemenu&quot;&gt;InGameMenu&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_19.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-20] : InGameMenu
인게임메뉴는 게임 진행중 왼쪽 Shift키를 통해 열 수 있다. 배경에 쓰이는 Bar 2개와 Button 5개, 버튼에 해당하는 메뉴설명인 Font로 구현을 하였다.
화살표 좌, 우 키로 이동하고 원하는 메뉴에서 A키를 누르면 넘어가게 되는데, 처음부터 장비, 중요아이템, 지도, 설정, 메인메뉴로 돌아가기 순으로 되어있다.
현재 지도는 구현이 되어있지 않다.&lt;/p&gt;

&lt;h3 id=&quot;inventory와-item&quot;&gt;Inventory와 Item&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/Dx_20.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 1-21] : Inventory&lt;br /&gt;
Item은 소모성 아이템과 장비아이템으로 나눌 수 있다. 활성 슬롯 밑에 있는 슬롯3칸은 퀵슬롯으로 소모성 아이템 같은 경우는 이곳에 등록을 한 뒤 게임에서 등록된 다른 아이템으로 바꿔가면서 사용할 수 있다. 지속 슬롯 밑 2칸은 장비 아이템을 등록하는 슬롯이다.
인벤토리는 소모성 아이템과 장비 아이템을 따로 저장하여 관리하며, 그로 인해 활성 슬롯에 커서가 올라가 있으면 인벤토리 내 소모성 아이템만 출력이 되게 하고, 지속 슬롯에 커서가 올라가게 되면 장비 아이템만 출력이 된다. 인벤토리에서 아이템을 빼서 퀵슬롯에 등록하게 되면 아이템은 인벤토리에서 삭제되고 퀵슬롯으로 옮겨가게 된다. 아이템을 저장하는 곳이 두 곳인 셈이다. 플레이어의 슬롯에 등록된 아이템은 언제든지 다시 인벤토리로 옮길 수 있는데 해제하고 싶은 아이템 커서에다 A키를 누르면 커서가 인벤토리로 옮겨지는데, 아이템을 바꾸고 싶다면 바꾸고 싶은 아이템으로 커서를 옮겨 A키를 누르고 장착해제하고 싶다면 None에다 두고 A키를 누르면 된다. 퀵슬롯에서 아이템을 해제하면 반대로 퀵슬롯에서 인벤토리로 아이템이 넘어가게된다. 인벤토리는 아이템이 들어올 때 정렬을 하게 되는데, 각 아이템은 고유의 ID값이 존재하고 인벤토리 내에서는 이 ID값을 기준으로 정렬을 한다.&lt;/p&gt;</content><author><name>tonnac</name></author><category term="Project" /><category term="DirectX11" /><category term="Momodora" /><summary type="html">1. 게임의 개요 게임: 모모도라: 달 아래의 진혼곡 모작 DirectX 11 컨버팅 인원: 개인 기간: 3주 2. 게임 시스템 Core 와 Sample 클래스 [그림 1-1] : Core 와 Sample의 클래스 다이어그램 Device는 DirectX를 사용하기 위해 기본적인 장치들을 생성하는 클래스로, 이를 윈도우를 띄우는 wClass가 상속하는 구조로 되어있다. 이를 다시 Core 클래스가 상속하는데, Core에서는 게임에 사용되는 전반적인 클래스들을 초기화 한다. Filepath 클래스는 게임에 쓰이는 리소스들의 경로를 저장하는데 쓰이는데, 함수와 멤버 모두 정적으로 구성되어있다. SpriteMgr와 FSMMgr는 각각 Sprite 와 FSM을 초기에 데이터를 저장하여 필요할 때 불러올 수 있도록 구성하였다. DirectWrite는 화면에 문자를 출력하기 위한 클래스인데, 현재는 FPS와 게임시간 SPF를 출력하는 용도로만 사용하고 있다. Timer는 게임의 시간에 관련된 부분들을 계산하는 클래스로, 위에서 말한 FPS와 게임시간 SPF를 Timer에서 계산을 한다. Sound는 게임에서 쓰는 사운드들을 출력하기 위한 클래스로 게임내에서 배경음과 효과음을 따로 조절하기 위해 채널과 사운드를 배경과 효과음 따로 나눠서 저장하고 있다. DirectInput은 키의 입력을 받아 처리하는 클래스인데, 키의 입력을 홀드상태와 업상태를 구분하기 위해서 현재의 키 상태와 이전 프레임의 키 상태를 저장한다. Frame을 호출한 뒤에 코어에 마지막에 PostFrame을 호출해서 현재 상태를 이전 상태에 저장하는 방식이다. Sample은 이 Core를 상속하는 클래스로, 내부에서 SceneMgr 프레임과 렌더를 호출해서 게임이 진행이 된다. [그림 1-2] : Core의 시퀀스 다이어그램 SceneMgr와 Scene 클래스 SceneMgr는 Scene을 멤버로 둬서 현재의 Scene의 Frame과 Render를 호출한다. Scene의 전환이 일어나면 현재의 Scene을 Release한 뒤, getScene함수를 통해서 바뀌는 Scene을 생성해서 다시 Frame과 Render를 호출한다. Scene은 생성을 할 때, 오브젝트들을 생성해서 배치 한 뒤, ObjectMgr에 추가하여 ObjectMgr의 Frame과 Render를 호출한다. [그림 1-3] : Scene과 SceneMgr의 클래스 다이어그램 게임 진행중에 지나온 Scene도 다시 돌아갈 수 있게끔, GameScene은 추가적으로 InverseInit 함수를 재정의하게 하여, 플레이어가 뒤 Scene에서 앞 Scene으로 올 때에는 오브젝트를 반대로 배치할 수 있도록 하였다. [그림 1-4] : Scene과 SceneMgr의 시퀀스 다이어그램 Shader와 Texture 클래스 [그림 1-5] : Shader와 Texture의 클래스 다이어그램 Shader와 Texture는 모두 매니저 클래스를 통해 관리하며, 매니저의 Load함수를 호출하면 우선 사용자가 원하는 데이터가 캐시에 있는지 확인을 한다. 있으면 바로 그 데이터를 반환하고, 없을 경우는 전체 데이터를 통해서 똑같은 작업을 한다. 전체데이터에도 없으면 만들어서 반환하는 구조로 되어있다. [그림 1-6] : ShaderMgr과 TextureMgr의 시퀀스 다이어그램 ObjectMgr과 Object 클래스 [그림 1-7] : ObjectMgr과 Object의 클래스 다이어그램 Basic_Object는 오브젝트 생성시에 필요한 기본적인 버퍼 등을 가지고 있는 클래스로, Object는 이 Basic_Object를 멤버로 가진다. Object는 상수 버퍼를 사용하기위한 구조체와 정점들을 STL 벡터에 보관하며 충돌체크를 위한 충돌크기와 센터위치 값을 가진다. Plane_Object는 정점 4개로 사각형을 출력하기 위한 클래스로 이를 위해 정점의 인덱스들을 벡터에 저장하게 하였다. ObjectMgr은 오브젝트들을 관리하기 위한 클래스로 Plane_Object를 상속받는 클래스별로 따로 관리를 한다. ObjectMgr엔 컨테이너를 순회하며 Frame과 Render를 호출하는 함수가 템플릿으로 정의를 해서, 각각 컨테이너별로 따로 Frame과 Render를 호출한다. [그림 1-8] : ObjectMgr의 시퀀스 다이어그램 Effect클래스 [그림 1-9] : Effect의 클래스 다이어그램 PlayerEffect는 플레이어의 공격에 관련된 이펙트가 있다. 근접공격 3단계와 공중 공격, 화살이펙트가 이 클래스를 상속한다. Misc는 플레이어의 버프효과를 나타내기 위한 클래스로 MiscSet은 이 Misc클래스를 배열로 둬서 하나의 세트를 구성한다. 현재 구현되 있는 아이템인 수정꽃을 사용하면 플레이어의 주위에 4개의 이펙트가 돌아다니게 되는데, 이를 통해 버프의 지속시간을 확인할 수 있게하였다. Character 클래스 [그림 1-10] : Character의 클래스 다이어그램 Character는 State 클래스와 함께 사용이 된다. State클래스는 캐릭터의 상태를 구현하는 클래스로 캐릭터의 이동이나 점프 공격 등 모든 상태를 구현하고 그 상태를 통해서 행동을 제약하는 방식으로 구성이 돼있다. Character는 자신의 모든 상태를 STL map에 저장하고 있다. State와 Character는 상호 참조 가능한 형태로, 만약 현재 상태에서 다른 상태로의 변화가 발생하면 State는 Character의 setState로 현재의 상태를 변경 시키고, Character는 해당하는 상태로 현재상태를 바꾸고 계속해서 Frame과 Render를 호출하는 방식이다. [그림 1-11] : Character의 시퀀스 다이어그램 State [그림 1-12]: State의 클래스 다이어그램 State는 EnemyState와 PlayerState로 나뉘어져있다. PlayerState 플레이어의 상태는 키보드 입력키에 의해 변하게 된다. 방향키로 이동을 하고 A키로 점프, S키로 근접공격, D키로 활공격을 할 수 있다. 실제 원작 게임에선 플레이어의 상태가 42개가 구현되어 있으나, 현재까지는 22개의 상태가 구현이 되어있다. EnemyState [그림 1-13]: EnemyState의 클래스 다이어그램 키보드로 상태가 변하는 플레이어와 달리 적 같은 경우는 상태별로 이벤트 발생 시 변경될 상태가 정의되어 있는 FSM이 필요하다. [그림 1-14]: 스크립트로 저장한 FSM 적들은 생성시에 FSMMgr을 통해서 하나의 FSM을 받아서 그 FSM에 맞게 행동을 한다. 이벤트가 발생하면 FinateStateMachine의 StateTransition 함수를 호출해서 반환되는 상태값으로 변경이 되는 방식이다. 그림 2-18을 예로들어서 현재 적이 Move 상태 일 때 플레이어를 발견해서 FINDTARGET이 발생하면 플레이어를 추적하는 Chase 상태가 된다. 현재 게임에서 구현 되어있는 FSM은 한 종류로 다음과 같다. [그림 1-15] : 몬스터 FSM UI [그림 1-16] : UI의 클래스 다이어그램 UI는 기본 구성요소들과 그 기본 구성요소들을 합하여 하나의 완성된 UI인 Menu 클래스 두 종류로 나눌 수 있다. LobbyMenu [그림 1-17] : LobbyMenu 로비 메뉴는 6개의 Bar와 1개의 Select Bar로 이루어져 있다. 방향키 위, 아래 버튼을 누르면 활성화된 슬롯이 바뀌는 방식으로 작동한다. Setting [그림 1-18] : 설정 화면 설정화면은 3개의 Bar와 1개의 SelectBar 그리고 2개의 ProgressBar로 이루어져 있다. 로비와 마찬가지로 위, 아래 키로 슬롯을 이동할 수 있으며, 추가적으로 효과음과 음악에 커서가 위치하면 화살표 좌, 우 키를 통해 볼륨을 조절할 수 있는데, 줄이게 되면 오른쪽에 바가 작아지고 키우게 되면 바가 커지는 형식으로 만들어져 있다. GameUI [그림 1-19] : GameUI GameUI는 3개의 Bar와 1개의 ProgressBar와 한 개의 ItemSlot, 4개의 폰트로 제작하였다. GameUI는 게임이 진행되는 동안 항상 왼쪽 위 모서리에 고정된 상태로 출력이 되며, 왼쪽 끝에 있는 아이템 슬롯은 현재 퀵슬롯에 등록된 아이템의 아이콘과 해당 아이템의 개수를 보여준다. 또한 퀵슬롯에 다른 아이템이 등록되어 있다면, E키를 통해서 언제든지 다음 아이템으로 전환할 수도 있다. HP바는 플레이어의 HP가 최대치일때는 그림과 같이 바가 가득 찬 상태로 있고, HP가 줄어들면 바의 크기도 같이 줄어들게 된다. 그 아래의 숫자 3개는 게임상 화폐를 보여주는 UI인데, 현재까지는 구현은 되어있지 않다. InGameMenu [그림 1-20] : InGameMenu 인게임메뉴는 게임 진행중 왼쪽 Shift키를 통해 열 수 있다. 배경에 쓰이는 Bar 2개와 Button 5개, 버튼에 해당하는 메뉴설명인 Font로 구현을 하였다. 화살표 좌, 우 키로 이동하고 원하는 메뉴에서 A키를 누르면 넘어가게 되는데, 처음부터 장비, 중요아이템, 지도, 설정, 메인메뉴로 돌아가기 순으로 되어있다. 현재 지도는 구현이 되어있지 않다. Inventory와 Item [그림 1-21] : Inventory Item은 소모성 아이템과 장비아이템으로 나눌 수 있다. 활성 슬롯 밑에 있는 슬롯3칸은 퀵슬롯으로 소모성 아이템 같은 경우는 이곳에 등록을 한 뒤 게임에서 등록된 다른 아이템으로 바꿔가면서 사용할 수 있다. 지속 슬롯 밑 2칸은 장비 아이템을 등록하는 슬롯이다. 인벤토리는 소모성 아이템과 장비 아이템을 따로 저장하여 관리하며, 그로 인해 활성 슬롯에 커서가 올라가 있으면 인벤토리 내 소모성 아이템만 출력이 되게 하고, 지속 슬롯에 커서가 올라가게 되면 장비 아이템만 출력이 된다. 인벤토리에서 아이템을 빼서 퀵슬롯에 등록하게 되면 아이템은 인벤토리에서 삭제되고 퀵슬롯으로 옮겨가게 된다. 아이템을 저장하는 곳이 두 곳인 셈이다. 플레이어의 슬롯에 등록된 아이템은 언제든지 다시 인벤토리로 옮길 수 있는데 해제하고 싶은 아이템 커서에다 A키를 누르면 커서가 인벤토리로 옮겨지는데, 아이템을 바꾸고 싶다면 바꾸고 싶은 아이템으로 커서를 옮겨 A키를 누르고 장착해제하고 싶다면 None에다 두고 A키를 누르면 된다. 퀵슬롯에서 아이템을 해제하면 반대로 퀵슬롯에서 인벤토리로 아이템이 넘어가게된다. 인벤토리는 아이템이 들어올 때 정렬을 하게 되는데, 각 아이템은 고유의 ID값이 존재하고 인벤토리 내에서는 이 ID값을 기준으로 정렬을 한다.</summary></entry><entry><title type="html">[WinAPI] WinAPI를 이용한 모모도라 모작</title><link href="https://tonnac.github.io/project/winapi/WinApi/" rel="alternate" type="text/html" title="[WinAPI] WinAPI를 이용한 모모도라 모작" /><published>2021-02-12T00:00:00+00:00</published><updated>2021-02-12T00:00:00+00:00</updated><id>https://tonnac.github.io/project/winapi/WinApi</id><content type="html" xml:base="https://tonnac.github.io/project/winapi/WinApi/">&lt;h1 id=&quot;1-게임의-개요&quot;&gt;1. 게임의 개요&lt;/h1&gt;

&lt;p&gt;게임: 모모도라: 달 아래의 진혼곡 모작&lt;br /&gt;
인원: 개인&lt;br /&gt;
기간: 3주&lt;br /&gt;&lt;/p&gt;

&lt;!-- [실행파일다운](https://tonnac.github.io/assets/MomodoraWinAPI.7z) --&gt;

&lt;h1 id=&quot;2-게임의-시스템&quot;&gt;2. 게임의 시스템&lt;/h1&gt;

&lt;h2 id=&quot;core-와-sample-클래스&quot;&gt;Core 와 Sample 클래스&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_00.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;[그림 2-1] : Core 와 Sample의 클래스 다이어그램&lt;br /&gt;
Core 클래스는 윈도우를 띄우는데 사용하는 Window 클래스를 상속받아 사용한다. Core의 멤버로는 Timer 클래스가 있다.&lt;br /&gt;
Timer 클래스는 Frame()의 호출 시간을 체크하여 전에 호출된 시간과 비교한후 FPS와 SPF 그리고 게임이 진행된 총 시간을 계산한다.
Input 클래스와 Sound 클래스는 싱글톤으로 정의가 되어있다.
Input같은 경우는 현재의 키 상태를 체크하는 getKeyState 함수가 있는데 이를 통해 플레이어의 입력을 처리할 수 있게 된다.
Sound 클래스는 게임 내 사운드를 출력하기 위한 클래스로 Core의 GameInit함수에서 사운드 파일을 불러들여 저장을 한 후, 필요할 때 재생을 시킬 수 있는 구조로 되어있다.
Core 클래스는 Init, Frame, Render, Release 함수를 가상함수로 정의해서 이를 상속하는 클래스의 필요에 따라 재정의 할 수 있게 되어있다.
Sample 클래스는 Core 클래스를 상속하는 클래스로 게임의 전반적인 내용을 처리하는 클래스이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_01.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-2] : Core의 시퀀스 다이어그램&lt;br /&gt;
Core의 GameFrame함수가 호출되면 순서대로 Timer, Input, Sound, Sample의 Frame이 호출되고, 그 후에 GameRender를 통해 Timer와 Sample의 Render를 호출하는 방식으로 구성 돼있다.&lt;/p&gt;

&lt;h2 id=&quot;scenemgr-와-scene-클래스&quot;&gt;SceneMgr 와 Scene 클래스&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_02.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-3] : SceneMgr의 클래스 다이어그램&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_03.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-4] : Scene의 클래스 다이어그램&lt;br /&gt;
SceneMgr은 Scene을 멤버로 가지고 있고 Frame과 Render에서 현재 Scene 의 Frame과 Render를 호출하는 방식으로 진행된다.
Scene의 전환은 Frame의 반환값으로 파악하며 True가 반환되면 계속 진행하고 False가 반환하면 현재 Scene을 소멸시키고 다음 Scene을 생성해서 진행하는 형태이다.
Scene의 멤버는 여러 오브젝트들이 있는데, 공통적으로 배경을 담당하는 BKObject와 Scene전환마다 페이드아웃효과를 주는 FadeObject클래스가 있다.
또한 GameScene같은 경우는 Player와 Enemy클래스를 멤버로 가지고, 추가적으로 캐릭터의 이동시에 다른 오브젝트들을 이동시키는 Scroll 클래스가 있다.
현재 프로그램에는 오브젝트를 관리하는 클래스가 존재하지 않고, 이렇게 Scene내에 오브젝트들을 배치하고 관리하는 방식으로 진행된다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_04.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-5] : SceneMgr와 Scene의 시퀀스 다이어그램&lt;/p&gt;

&lt;h2 id=&quot;object클래스&quot;&gt;Object클래스&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_05.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-6] : Object의 클래스 다이어그램&lt;br /&gt;
Object 클래스를 구성하는 멤버 중 하나인 Bitmap은 비트맵 파일을 읽어 드려서 그 파일의 정보를 저장하는 클래스이다.
Rendering 클래스는 화면에 출력을 담당하는 클래스다.
Object는 Render함수가 호출 되면 현재 자신의 Rendering의 Render를 호출하는 방식으로 구성돼 있다.
Rendering은 확대와 반전이 가능한 ScaleRendering, 회전을 줄 수 있는 RotateRendering, 알파블랜드를 할 수 있는 AlphaRendering으로 나뉘어져 있다.
Rendering은 생성시에 해당 Object객체를 인자로 받아서 그 객체의 센터 값, 출력위치 값, 충돌크기, 비트맵의 포지션 값을 포인터로 저장한다.
그렇게 함으로써 Object의 Frame()에서 바뀌는 여러 데이터들을 Render를 할 때 포인터의 값을 읽어드리면서 그대로 출력을 하게 된다.
또한 Object에는 setRendering 함수가 구현 돼있어서, 언제든지 다른 Rendering으로 바꿀 수 있도록 되어있다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_06.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-7]: Object의 시퀀스 다이어그램&lt;/p&gt;

&lt;h3 id=&quot;terrain&quot;&gt;Terrain&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_07.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-8] : Terrain의 클래스 다이어그램&lt;br /&gt;
Terrain은 게임에서 쓰이는 지형을 표현하기 위한 클래스다.
기본적인 지형 외에 플레이어가 아래로 떨어질 수 있는 Downable과 사다리 역할을 하는 Ladder, 그리고 닿으면 즉사를 하는 Trap클래스가 존재한다.
또한 다른 오브젝트와 충돌 처리를 하는 Collision함수가 들어 있다. Collision함수는 다른 오브젝트와의 충돌을 계산할 때, 충돌 여부를 계산한 후에 충돌이 일어났으면 충돌영역을 다시 계산하여 충돌의 방향을 계산하는데 이를 통해 Downable같은 경우는 플레이어의 좌우와 밑에서 위로오는 충돌은 무시하면 위에서 오는 충돌만 계산을 한다.
2.3.2. BKObject
&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_08.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-9] : BKOBject의 클래스 다이어그램&lt;br /&gt;
BKObject는 게임의 배경을 담당하는 클래스이며, 추가적으로 Scene에서 지형들을 배치하고 그 지형들을 해당 Scene의 BKObject에 추가해서 배경과 지형을 같이 BKObject에서 관리를 한다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_09.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-10]: BKOBject의 시퀀스 다이어그램&lt;/p&gt;

&lt;h3 id=&quot;effect&quot;&gt;Effect&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_10.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-11]: Effect의 클래스 다이어그램&lt;br /&gt;
Effect클래스는 현재 플레이어의 근접공격3개와 공중 공격, 활 공격 총 5개가 존재한다.
멤버로 Sprite클래스를 가지고 있는데 Sprite는 STL 벡터에 RECT를 저장하고 Frame호출 시에 오프셋만큼 시간이 경과하면 다음 RECT를 가리키고 Effect에서 RECT를 불러와서 비트맵의 불러오는 위치를 조정하여 애니메이션 효과를 줄 수 있게 하였다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_11.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-12]: Effect의 시퀀스 다이어그램&lt;/p&gt;

&lt;h3 id=&quot;character&quot;&gt;Character&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_12.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-13]: Character의 클래스 다이어그램&lt;br /&gt;
Character는 State 클래스와 함께 사용이 된다. State클래스는 캐릭터의 상태를 구현하는 클래스로 캐릭터의 이동이나 점프 공격 등 모든 상태를 구현하고 그 상태를 통해서 행동을 제약하는 방식으로 구성이 돼있다. Character는 자신의 모든 상태를 STL map에 저장하고 있다. State와 Character는 상호 참조 가능한 형태로, 만약 현재 상태에서 다른 상태로의 변화가 발생하면 State는 Character의 setState로 현재의 상태를 변경 시키고, Character는 해당하는 상태로 현재상태를 바꾸고 계속해서 Frame과 Render를 호출하는 방식이다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_13.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-14]: Character의 시퀀스 다이어그램&lt;/p&gt;

&lt;h2 id=&quot;state&quot;&gt;State&lt;/h2&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_14.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-15]: State의 클래스 다이어그램&lt;br /&gt;
State는 EnemyState와 PlayerState로 나뉘어져있다.&lt;/p&gt;

&lt;h3 id=&quot;playerstate&quot;&gt;PlayerState&lt;/h3&gt;

&lt;p&gt;플레이어의 상태는 키보드 입력키에 의해 변하게 된다.
방향키로 이동을 하고 A키로 점프, S키로 근접공격, D키로 활공격을 할 수 있다. 실제 원작 게임에선 플레이어의 상태가 42개가 구현되어 있으나, 현재까지는 22개의 상태가 구현이 되어있다.&lt;/p&gt;

&lt;h3 id=&quot;enemystate&quot;&gt;EnemyState&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_15.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-16]: EnemyState의 클래스 다이어그램&lt;br /&gt;
키보드로 상태가 변하는 플레이어와 달리 적 같은 경우는 상태별로 이벤트 발생 시 변경될 상태가 정의되어 있는 FSM이 필요하다.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_16.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
[그림 2-17]: 스크립트로 저장한 FSM&lt;br /&gt;
적들은 생성시에 FSMMgr을 통해서 하나의 FSM을 받아서 그 FSM에 맞게 행동을 한다. 이벤트가 발생하면 FinateStateMachine의 StateTransition 함수를 호출해서 반환되는 상태값으로 변경이 되는 방식이다. 그림 2-17을 예로들어서 현재 적이 Move 상태 일 때 플레이어를 발견해서 FINDTARGET이 발생하면 플레이어를 추적하는 Chase 상태가 된다.
현재 게임에서 구현 되어있는 FSM은 한 종류로 다음과 같다.
&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_18.png&quot; alt=&quot;&quot; /&gt;&lt;br /&gt;
&lt;img src=&quot;https://tonnac.github.io/assets/images/winapi_momo_17.png&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;</content><author><name>tonnac</name></author><category term="Project" /><category term="WinAPI" /><category term="Momodora" /><summary type="html">1. 게임의 개요 게임: 모모도라: 달 아래의 진혼곡 모작 인원: 개인 기간: 3주 2. 게임의 시스템 Core 와 Sample 클래스 [그림 2-1] : Core 와 Sample의 클래스 다이어그램 Core 클래스는 윈도우를 띄우는데 사용하는 Window 클래스를 상속받아 사용한다. Core의 멤버로는 Timer 클래스가 있다. Timer 클래스는 Frame()의 호출 시간을 체크하여 전에 호출된 시간과 비교한후 FPS와 SPF 그리고 게임이 진행된 총 시간을 계산한다. Input 클래스와 Sound 클래스는 싱글톤으로 정의가 되어있다. Input같은 경우는 현재의 키 상태를 체크하는 getKeyState 함수가 있는데 이를 통해 플레이어의 입력을 처리할 수 있게 된다. Sound 클래스는 게임 내 사운드를 출력하기 위한 클래스로 Core의 GameInit함수에서 사운드 파일을 불러들여 저장을 한 후, 필요할 때 재생을 시킬 수 있는 구조로 되어있다. Core 클래스는 Init, Frame, Render, Release 함수를 가상함수로 정의해서 이를 상속하는 클래스의 필요에 따라 재정의 할 수 있게 되어있다. Sample 클래스는 Core 클래스를 상속하는 클래스로 게임의 전반적인 내용을 처리하는 클래스이다. [그림 2-2] : Core의 시퀀스 다이어그램 Core의 GameFrame함수가 호출되면 순서대로 Timer, Input, Sound, Sample의 Frame이 호출되고, 그 후에 GameRender를 통해 Timer와 Sample의 Render를 호출하는 방식으로 구성 돼있다. SceneMgr 와 Scene 클래스 [그림 2-3] : SceneMgr의 클래스 다이어그램 [그림 2-4] : Scene의 클래스 다이어그램 SceneMgr은 Scene을 멤버로 가지고 있고 Frame과 Render에서 현재 Scene 의 Frame과 Render를 호출하는 방식으로 진행된다. Scene의 전환은 Frame의 반환값으로 파악하며 True가 반환되면 계속 진행하고 False가 반환하면 현재 Scene을 소멸시키고 다음 Scene을 생성해서 진행하는 형태이다. Scene의 멤버는 여러 오브젝트들이 있는데, 공통적으로 배경을 담당하는 BKObject와 Scene전환마다 페이드아웃효과를 주는 FadeObject클래스가 있다. 또한 GameScene같은 경우는 Player와 Enemy클래스를 멤버로 가지고, 추가적으로 캐릭터의 이동시에 다른 오브젝트들을 이동시키는 Scroll 클래스가 있다. 현재 프로그램에는 오브젝트를 관리하는 클래스가 존재하지 않고, 이렇게 Scene내에 오브젝트들을 배치하고 관리하는 방식으로 진행된다. [그림 2-5] : SceneMgr와 Scene의 시퀀스 다이어그램 Object클래스 [그림 2-6] : Object의 클래스 다이어그램 Object 클래스를 구성하는 멤버 중 하나인 Bitmap은 비트맵 파일을 읽어 드려서 그 파일의 정보를 저장하는 클래스이다. Rendering 클래스는 화면에 출력을 담당하는 클래스다. Object는 Render함수가 호출 되면 현재 자신의 Rendering의 Render를 호출하는 방식으로 구성돼 있다. Rendering은 확대와 반전이 가능한 ScaleRendering, 회전을 줄 수 있는 RotateRendering, 알파블랜드를 할 수 있는 AlphaRendering으로 나뉘어져 있다. Rendering은 생성시에 해당 Object객체를 인자로 받아서 그 객체의 센터 값, 출력위치 값, 충돌크기, 비트맵의 포지션 값을 포인터로 저장한다. 그렇게 함으로써 Object의 Frame()에서 바뀌는 여러 데이터들을 Render를 할 때 포인터의 값을 읽어드리면서 그대로 출력을 하게 된다. 또한 Object에는 setRendering 함수가 구현 돼있어서, 언제든지 다른 Rendering으로 바꿀 수 있도록 되어있다. [그림 2-7]: Object의 시퀀스 다이어그램 Terrain [그림 2-8] : Terrain의 클래스 다이어그램 Terrain은 게임에서 쓰이는 지형을 표현하기 위한 클래스다. 기본적인 지형 외에 플레이어가 아래로 떨어질 수 있는 Downable과 사다리 역할을 하는 Ladder, 그리고 닿으면 즉사를 하는 Trap클래스가 존재한다. 또한 다른 오브젝트와 충돌 처리를 하는 Collision함수가 들어 있다. Collision함수는 다른 오브젝트와의 충돌을 계산할 때, 충돌 여부를 계산한 후에 충돌이 일어났으면 충돌영역을 다시 계산하여 충돌의 방향을 계산하는데 이를 통해 Downable같은 경우는 플레이어의 좌우와 밑에서 위로오는 충돌은 무시하면 위에서 오는 충돌만 계산을 한다. 2.3.2. BKObject [그림 2-9] : BKOBject의 클래스 다이어그램 BKObject는 게임의 배경을 담당하는 클래스이며, 추가적으로 Scene에서 지형들을 배치하고 그 지형들을 해당 Scene의 BKObject에 추가해서 배경과 지형을 같이 BKObject에서 관리를 한다. [그림 2-10]: BKOBject의 시퀀스 다이어그램 Effect [그림 2-11]: Effect의 클래스 다이어그램 Effect클래스는 현재 플레이어의 근접공격3개와 공중 공격, 활 공격 총 5개가 존재한다. 멤버로 Sprite클래스를 가지고 있는데 Sprite는 STL 벡터에 RECT를 저장하고 Frame호출 시에 오프셋만큼 시간이 경과하면 다음 RECT를 가리키고 Effect에서 RECT를 불러와서 비트맵의 불러오는 위치를 조정하여 애니메이션 효과를 줄 수 있게 하였다. [그림 2-12]: Effect의 시퀀스 다이어그램 Character [그림 2-13]: Character의 클래스 다이어그램 Character는 State 클래스와 함께 사용이 된다. State클래스는 캐릭터의 상태를 구현하는 클래스로 캐릭터의 이동이나 점프 공격 등 모든 상태를 구현하고 그 상태를 통해서 행동을 제약하는 방식으로 구성이 돼있다. Character는 자신의 모든 상태를 STL map에 저장하고 있다. State와 Character는 상호 참조 가능한 형태로, 만약 현재 상태에서 다른 상태로의 변화가 발생하면 State는 Character의 setState로 현재의 상태를 변경 시키고, Character는 해당하는 상태로 현재상태를 바꾸고 계속해서 Frame과 Render를 호출하는 방식이다. [그림 2-14]: Character의 시퀀스 다이어그램 State [그림 2-15]: State의 클래스 다이어그램 State는 EnemyState와 PlayerState로 나뉘어져있다. PlayerState 플레이어의 상태는 키보드 입력키에 의해 변하게 된다. 방향키로 이동을 하고 A키로 점프, S키로 근접공격, D키로 활공격을 할 수 있다. 실제 원작 게임에선 플레이어의 상태가 42개가 구현되어 있으나, 현재까지는 22개의 상태가 구현이 되어있다. EnemyState [그림 2-16]: EnemyState의 클래스 다이어그램 키보드로 상태가 변하는 플레이어와 달리 적 같은 경우는 상태별로 이벤트 발생 시 변경될 상태가 정의되어 있는 FSM이 필요하다. [그림 2-17]: 스크립트로 저장한 FSM 적들은 생성시에 FSMMgr을 통해서 하나의 FSM을 받아서 그 FSM에 맞게 행동을 한다. 이벤트가 발생하면 FinateStateMachine의 StateTransition 함수를 호출해서 반환되는 상태값으로 변경이 되는 방식이다. 그림 2-17을 예로들어서 현재 적이 Move 상태 일 때 플레이어를 발견해서 FINDTARGET이 발생하면 플레이어를 추적하는 Chase 상태가 된다. 현재 게임에서 구현 되어있는 FSM은 한 종류로 다음과 같다.</summary></entry></feed>