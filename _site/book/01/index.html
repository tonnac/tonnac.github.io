<!doctype html>
<!--
  Minimal Mistakes Jekyll Theme 4.22.0 by Michael Rose
  Copyright 2013-2020 Michael Rose - mademistakes.com | @mmistakes
  Free for personal and commercial use under the MIT license
  https://github.com/mmistakes/minimal-mistakes/blob/master/LICENSE
-->
<html lang="en" class="no-js">
  <head>
    <meta charset="utf-8">

<!-- begin _includes/seo.html --><title>[Modern Effective C++] 1. 템플릿 타입 추론 규칙을 숙지 - 블로그</title>
<meta name="description" content="template &lt;typename T&gt; void f(ParamType param); f(expr);   위와같은 템플릿 함수를 호출할때 컴파일러는 expr을 이용해 T 와 ParamType을 추론한다.     T에대해 추론된 형식은 항상 expr의 형식이 되지 않는다. expr의 형식외에도 ParamType의 형태에도 의존하기 때문. ParamType형태에 따라 세 가지 경우로 나뉜다.           ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우           ParamType이 Universal Reference인 경우           ParamType이 포인터도 아니고 참조도 아닌 경우      템플릿 추론 방식  1. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우  template &lt;typename T&gt; void f(T&amp; param);   // param은 참조 형식  int x = 27          // int const int cx = x;   // const int const int&amp; rx = x;  // const int&amp;  //위의 변수들로 f 호출결과 f(x);               // T는 int, param은 int&amp; f(cx);              // T는 const int, param은 const int&amp; f(rx);              // T는 const int, param은 const int&amp;   이를 통해 알수있는것은     객체의 const성은 T에 대해 추론된 타입의 일부가 된다.   타입 추론 과정에서 참조성은 무시가된다.   2. ParamType이 Universal Reference인 경우  템플릿이 Universal Reference 매개변수를 받는 경우에 매개변수의 선언은 오른값 참조와 같은 모습이지만, 왼값 인수가 전달되면 다른 방식으로 행동한다.        expr이 왼값이면, T 와 ParamType 둘 다 왼값 참조로 추론된다.   expr이 오른값이면, 1번과같이 ‘정상적인’ 규칙들이 적용   template &lt;typename T&gt; void f(T&amp;&amp; param);      // param은 Universal Reference  int x = 27;             // 이전과 동일 const int cx = x        // 이전과 동일 const int&amp; rx = x       // 이전과 동일  f(x);                   // x는 왼값 T와 param의 형식 모두 int&amp; f(cx);                  // cx는 왼값 T와 param의 형식 모두 const int&amp; f(rx);                  // rx는 왼값 T와 param의 형식 모두 const int&amp;  f(27);                  // 27은 오른값 T는 int, param 타입은 int&amp;&amp;      Universal Reference가 관여하면 왼값 인수와 오른값 인수에 대해 서로 다른 타입추론이 적용된다.   3. ParamType이 포인터도 아니고 참조도 아닌 경우  인수가 값으로 전달되는 경우다.  template &lt;typename T&gt; void f(T param);   param은 인수의 복사본으로 새로운 객체이다. 따라서 expr에서 T가 추론되는 과정에서 다음 규칙들이 적용된다.     expr이 참조형식이면, 이전처럼 참조 부분은 무시된다.   expr이 참조를 무시하고, expr이 const이면 그 const 역시 무시한다. volatile역시 무시된다.   int x = 27;             // 이전과 동일 const int cx = x        // 이전과 동일 const int&amp; rx = x       // 이전과 동일  f(x);                   // T와 param의 형식 모두 int f(cx);                  // T와 param의 형식 모두 int f(rx);                  // T와 param의 형식 모두 int      param은 cx나 rx의 복사본이므로, const가 아니게된다.   const char* const ptr =  // ptr은 const 객체를 가리키는 const 포인터   &quot;Fun with pointers&quot;  f(ptr);   ptr은 다른 변수의 주소값을 가리키도록 변경할 수 없으며, 문자열 또한 변경이 불가능하다. ptr을 f에 전달하면 포인터 자체는 값으로 전달된다. 그래서 값 전달 방식의 타입추론과 같은 규칙으로 적용된다. 결과적으로 param 타입은 const char*가 되어서 const 문자열을 가리키는 수정 가능한 포인터가 된다.  배열 인수  const char name[] = &quot;J. P. Briggs&quot;  // name의 타입은 const char[13] const char* ptrToName = name        // 배열이 포인터로 붕괴된다.  template&lt;typename T&gt; void f(T param);    // 값 전달 매개변수가 있는 템플릿 f(name);   템플릿 함수에 값으로 전달되는 배열의 형식은 포인터로 추론된다. 즉 T는 const char*로 추론된다. 함수의 매개변수를 배열로 선언 할 수는 없지만, 배열에 대한 참조로 선언할 수는 있다.  template&lt;typename T&gt; void f(T&amp; param);     // 참조 전달 매개변수가 있는 템플릿 f(name);              // 배열을 f에 전달   param타입을 바꿔서 호출하면 T에 대해 추론된 형식은 배열의 실제 형식이된다. 이 예에서는 T는 const char [13]이 되고 param의 타입은 const char (&amp;)[13]이 된다.  함수 인수  void someFunc(int, double); // someFunc는 함수;                             // 형식은 void(int, double) template&lt;typename T&gt; void f1(T param);           // f1의 param은 값 전달 방식  template&lt;typename T&gt; void f1(T&amp; param);          // f2의 param은 값 전달 방식  f1(someFunc);               // param은 함수 포인터로 추론됨                             // 형식은 void(*)(int, double)  f2(someFunc);               // param은 함수 참조로 추론됨                             // 형식은 void (&amp;)(int, double)   결론     템플릿 타입 추론 도중 참조 형식의 인수들은 참조성이 무시된다.    Universal Reference에 대한 타입 추론 과정에서 왼값 인수들은 특별하게 취급된다.   값 전달 방식의 매개변수에 대한 타입 추론 과정에서 const 또는 volatile은 제거된다.   타입 추론 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다. 단, 인수가 초기화하는 데 쓰이는 경우에는 포인터로 붕괴 하지 않는다.">


  <meta name="author" content="tonnac">
  
  <meta property="article:author" content="tonnac">
  


<meta property="og:type" content="article">
<meta property="og:locale" content="en_US">
<meta property="og:site_name" content="블로그">
<meta property="og:title" content="[Modern Effective C++] 1. 템플릿 타입 추론 규칙을 숙지">
<meta property="og:url" content="https://tonnac.github.io/book/01/">


  <meta property="og:description" content="template &lt;typename T&gt; void f(ParamType param); f(expr);   위와같은 템플릿 함수를 호출할때 컴파일러는 expr을 이용해 T 와 ParamType을 추론한다.     T에대해 추론된 형식은 항상 expr의 형식이 되지 않는다. expr의 형식외에도 ParamType의 형태에도 의존하기 때문. ParamType형태에 따라 세 가지 경우로 나뉜다.           ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우           ParamType이 Universal Reference인 경우           ParamType이 포인터도 아니고 참조도 아닌 경우      템플릿 추론 방식  1. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우  template &lt;typename T&gt; void f(T&amp; param);   // param은 참조 형식  int x = 27          // int const int cx = x;   // const int const int&amp; rx = x;  // const int&amp;  //위의 변수들로 f 호출결과 f(x);               // T는 int, param은 int&amp; f(cx);              // T는 const int, param은 const int&amp; f(rx);              // T는 const int, param은 const int&amp;   이를 통해 알수있는것은     객체의 const성은 T에 대해 추론된 타입의 일부가 된다.   타입 추론 과정에서 참조성은 무시가된다.   2. ParamType이 Universal Reference인 경우  템플릿이 Universal Reference 매개변수를 받는 경우에 매개변수의 선언은 오른값 참조와 같은 모습이지만, 왼값 인수가 전달되면 다른 방식으로 행동한다.        expr이 왼값이면, T 와 ParamType 둘 다 왼값 참조로 추론된다.   expr이 오른값이면, 1번과같이 ‘정상적인’ 규칙들이 적용   template &lt;typename T&gt; void f(T&amp;&amp; param);      // param은 Universal Reference  int x = 27;             // 이전과 동일 const int cx = x        // 이전과 동일 const int&amp; rx = x       // 이전과 동일  f(x);                   // x는 왼값 T와 param의 형식 모두 int&amp; f(cx);                  // cx는 왼값 T와 param의 형식 모두 const int&amp; f(rx);                  // rx는 왼값 T와 param의 형식 모두 const int&amp;  f(27);                  // 27은 오른값 T는 int, param 타입은 int&amp;&amp;      Universal Reference가 관여하면 왼값 인수와 오른값 인수에 대해 서로 다른 타입추론이 적용된다.   3. ParamType이 포인터도 아니고 참조도 아닌 경우  인수가 값으로 전달되는 경우다.  template &lt;typename T&gt; void f(T param);   param은 인수의 복사본으로 새로운 객체이다. 따라서 expr에서 T가 추론되는 과정에서 다음 규칙들이 적용된다.     expr이 참조형식이면, 이전처럼 참조 부분은 무시된다.   expr이 참조를 무시하고, expr이 const이면 그 const 역시 무시한다. volatile역시 무시된다.   int x = 27;             // 이전과 동일 const int cx = x        // 이전과 동일 const int&amp; rx = x       // 이전과 동일  f(x);                   // T와 param의 형식 모두 int f(cx);                  // T와 param의 형식 모두 int f(rx);                  // T와 param의 형식 모두 int      param은 cx나 rx의 복사본이므로, const가 아니게된다.   const char* const ptr =  // ptr은 const 객체를 가리키는 const 포인터   &quot;Fun with pointers&quot;  f(ptr);   ptr은 다른 변수의 주소값을 가리키도록 변경할 수 없으며, 문자열 또한 변경이 불가능하다. ptr을 f에 전달하면 포인터 자체는 값으로 전달된다. 그래서 값 전달 방식의 타입추론과 같은 규칙으로 적용된다. 결과적으로 param 타입은 const char*가 되어서 const 문자열을 가리키는 수정 가능한 포인터가 된다.  배열 인수  const char name[] = &quot;J. P. Briggs&quot;  // name의 타입은 const char[13] const char* ptrToName = name        // 배열이 포인터로 붕괴된다.  template&lt;typename T&gt; void f(T param);    // 값 전달 매개변수가 있는 템플릿 f(name);   템플릿 함수에 값으로 전달되는 배열의 형식은 포인터로 추론된다. 즉 T는 const char*로 추론된다. 함수의 매개변수를 배열로 선언 할 수는 없지만, 배열에 대한 참조로 선언할 수는 있다.  template&lt;typename T&gt; void f(T&amp; param);     // 참조 전달 매개변수가 있는 템플릿 f(name);              // 배열을 f에 전달   param타입을 바꿔서 호출하면 T에 대해 추론된 형식은 배열의 실제 형식이된다. 이 예에서는 T는 const char [13]이 되고 param의 타입은 const char (&amp;)[13]이 된다.  함수 인수  void someFunc(int, double); // someFunc는 함수;                             // 형식은 void(int, double) template&lt;typename T&gt; void f1(T param);           // f1의 param은 값 전달 방식  template&lt;typename T&gt; void f1(T&amp; param);          // f2의 param은 값 전달 방식  f1(someFunc);               // param은 함수 포인터로 추론됨                             // 형식은 void(*)(int, double)  f2(someFunc);               // param은 함수 참조로 추론됨                             // 형식은 void (&amp;)(int, double)   결론     템플릿 타입 추론 도중 참조 형식의 인수들은 참조성이 무시된다.    Universal Reference에 대한 타입 추론 과정에서 왼값 인수들은 특별하게 취급된다.   값 전달 방식의 매개변수에 대한 타입 추론 과정에서 const 또는 volatile은 제거된다.   타입 추론 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다. 단, 인수가 초기화하는 데 쓰이는 경우에는 포인터로 붕괴 하지 않는다.">



  <meta property="og:image" content="https://tonnac.github.io/assets/images/avatar.jpg">





  <meta property="article:published_time" content="2021-03-01T00:00:00+00:00">





  

  


<link rel="canonical" href="https://tonnac.github.io/book/01/">




<script type="application/ld+json">
  {
    "@context": "https://schema.org",
    
      "@type": "Person",
      "name": "tonnac",
      "url": "https://tonnac.github.io/"
    
  }
</script>






<!-- end _includes/seo.html -->



  <link href="/feed.xml" type="application/atom+xml" rel="alternate" title="블로그 Feed">


<!-- https://t.co/dKP3o1e -->
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<script>
  document.documentElement.className = document.documentElement.className.replace(/\bno-js\b/g, '') + ' js ';
</script>

<!-- For all browsers -->
<link rel="stylesheet" href="/assets/css/main.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5/css/all.min.css">
<link rel="shortcut icon" type="image/png" href="assets/images/favicon.ico">

<!--[if IE]>
  <style>
    /* old IE unsupported flexbox fixes */
    .greedy-nav .site-title {
      padding-right: 3em;
    }
    .greedy-nav button {
      position: absolute;
      top: 0;
      right: 0;
      height: 100%;
    }
  </style>
<![endif]-->


    <!-- start custom head snippets -->

<!-- insert favicons. use https://realfavicongenerator.net/ -->

<!-- end custom head snippets -->

  </head>

  <body class="layout--single">
    <nav class="skip-links">
  <h2 class="screen-reader-text">Skip links</h2>
  <ul>
    <li><a href="#site-nav" class="screen-reader-shortcut">Skip to primary navigation</a></li>
    <li><a href="#main" class="screen-reader-shortcut">Skip to content</a></li>
    <li><a href="#footer" class="screen-reader-shortcut">Skip to footer</a></li>
  </ul>
</nav>

    <!--[if lt IE 9]>
<div class="notice--danger align-center" style="margin: 0;">You are using an <strong>outdated</strong> browser. Please <a href="https://browsehappy.com/">upgrade your browser</a> to improve your experience.</div>
<![endif]-->

    

<div class="masthead">
  <div class="masthead__inner-wrap">
    <div class="masthead__menu">
      <nav id="site-nav" class="greedy-nav">
        
        <a class="site-title" href="/">
          <!-- 블로그 -->
          홈
          
        </a>
        <ul class="visible-links"><li class="masthead__menu-item">
              <a href="/categories/">Category</a>
            </li><li class="masthead__menu-item">
              <a href="/tags/">Tags</a>
            </li></ul>
        
        <button class="greedy-nav__toggle hidden" type="button">
          <span class="visually-hidden">Toggle menu</span>
          <div class="navicon"></div>
        </button>
        <ul class="hidden-links hidden"></ul>
      </nav>
    </div>
  </div>
</div>


    <div class="initial-content">
      



<div id="main" role="main">
  
  <div class="sidebar sticky">
  


<div itemscope itemtype="https://schema.org/Person">

  
    <div class="author__avatar">
      
        <img src="/assets/images/avatar.jpg" alt="tonnac" itemprop="image">
      
    </div>
  

  <div class="author__content">
    
      <h3 class="author__name" itemprop="name">tonnac</h3>
    
    
      <div class="author__bio" itemprop="description">
        <p>오늘</p>

      </div>
    
  </div>

  <div class="author__urls-wrapper">
    <button class="btn btn--inverse">Follow</button>
    <ul class="author__urls social-icons">
      
        <li itemprop="homeLocation" itemscope itemtype="https://schema.org/Place">
          <i class="fas fa-fw fa-map-marker-alt" aria-hidden="true"></i> <span itemprop="name">South Korea</span>
        </li>
      

      
        
          
            <li><a href="mailto:tonnac35@gmail.com" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-envelope-square" aria-hidden="true"></i><span class="label">Email</span></a></li>
          
        
          
            <li><a href="https://tonnac.github.io/" rel="nofollow noopener noreferrer"><i class="fas fa-fw fa-link" aria-hidden="true"></i><span class="label">Website</span></a></li>
          
        
          
            <li><a href="https://github.com/tonnac/" rel="nofollow noopener noreferrer"><i class="fab fa-fw fa-github" aria-hidden="true"></i><span class="label">GitHub</span></a></li>
          
        
      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      

      <!--
  <li>
    <a href="http://link-to-whatever-social-network.com/user/" itemprop="sameAs" rel="nofollow noopener noreferrer">
      <i class="fas fa-fw" aria-hidden="true"></i> Custom Social Profile Link
    </a>
  </li>
-->
    </ul>
  </div>
</div>

  
  
    

<nav class="nav__list">
  <input id="ac-toc" name="accordion-toc" type="checkbox" />
  <label for="ac-toc">Toggle menu</label>
  <ul class="nav__items" id="category_tag_menu">
  
      <li>
        <span class="nav__sub-title">C++</span>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>




        <span class="nav__sub-title">UE4</span>
            <ul>
                
                    
                
                    
                
                    
                
                    
                        <li><a href="/categories/UE4" class="">언리얼엔진4 (3)</a></li>
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
        


        <span class="nav__sub-title">Book</span>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                        
                            
                        
                            
                        
                            
                                <li><a href="/tags/modern_effective_cpp" class="">Modern Effective C++(2)</a></li>
                            
                        
                            
                        
                            
                        
                            
                        
                            
                        
                    
                
                    
                
            </ul>

        <span class="nav__sub-title">etc</span>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
            <ul>
                
                    
                
                    
                
                    
                
                    
                
                    
                
                    
                
            </ul>
      </li>
  </ul>
</nav>
  
  </div>



  <article class="page" itemscope itemtype="https://schema.org/CreativeWork">
    <meta itemprop="headline" content="[Modern Effective C++] 1. 템플릿 타입 추론 규칙을 숙지">
    <meta itemprop="description" content="template &lt;typename T&gt;void f(ParamType param);f(expr);위와같은 템플릿 함수를 호출할때 컴파일러는 expr을 이용해 T 와 ParamType을 추론한다.  T에대해 추론된 형식은 항상 expr의 형식이 되지 않는다. expr의 형식외에도 ParamType의 형태에도 의존하기 때문. ParamType형태에 따라 세 가지 경우로 나뉜다.      ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우        ParamType이 Universal Reference인 경우        ParamType이 포인터도 아니고 참조도 아닌 경우  템플릿 추론 방식1. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우template &lt;typename T&gt;void f(T&amp; param);   // param은 참조 형식int x = 27          // intconst int cx = x;   // const intconst int&amp; rx = x;  // const int&amp;//위의 변수들로 f 호출결과f(x);               // T는 int, param은 int&amp;f(cx);              // T는 const int, param은 const int&amp;f(rx);              // T는 const int, param은 const int&amp;이를 통해 알수있는것은  객체의 const성은 T에 대해 추론된 타입의 일부가 된다.  타입 추론 과정에서 참조성은 무시가된다.2. ParamType이 Universal Reference인 경우템플릿이 Universal Reference 매개변수를 받는 경우에 매개변수의 선언은 오른값 참조와 같은 모습이지만, 왼값 인수가 전달되면 다른 방식으로 행동한다.  expr이 왼값이면, T 와 ParamType 둘 다 왼값 참조로 추론된다.  expr이 오른값이면, 1번과같이 ‘정상적인’ 규칙들이 적용template &lt;typename T&gt;void f(T&amp;&amp; param);      // param은 Universal Referenceint x = 27;             // 이전과 동일const int cx = x        // 이전과 동일const int&amp; rx = x       // 이전과 동일f(x);                   // x는 왼값 T와 param의 형식 모두 int&amp;f(cx);                  // cx는 왼값 T와 param의 형식 모두 const int&amp;f(rx);                  // rx는 왼값 T와 param의 형식 모두 const int&amp;f(27);                  // 27은 오른값 T는 int, param 타입은 int&amp;&amp;  Universal Reference가 관여하면 왼값 인수와 오른값 인수에 대해 서로 다른 타입추론이 적용된다.3. ParamType이 포인터도 아니고 참조도 아닌 경우인수가 값으로 전달되는 경우다.template &lt;typename T&gt;void f(T param);param은 인수의 복사본으로 새로운 객체이다. 따라서 expr에서 T가 추론되는 과정에서 다음 규칙들이 적용된다.  expr이 참조형식이면, 이전처럼 참조 부분은 무시된다.  expr이 참조를 무시하고, expr이 const이면 그 const 역시 무시한다. volatile역시 무시된다.int x = 27;             // 이전과 동일const int cx = x        // 이전과 동일const int&amp; rx = x       // 이전과 동일f(x);                   // T와 param의 형식 모두 intf(cx);                  // T와 param의 형식 모두 intf(rx);                  // T와 param의 형식 모두 int  param은 cx나 rx의 복사본이므로, const가 아니게된다.const char* const ptr =  // ptr은 const 객체를 가리키는 const 포인터  &quot;Fun with pointers&quot;f(ptr);ptr은 다른 변수의 주소값을 가리키도록 변경할 수 없으며, 문자열 또한 변경이 불가능하다.ptr을 f에 전달하면 포인터 자체는 값으로 전달된다. 그래서 값 전달 방식의 타입추론과 같은 규칙으로 적용된다.결과적으로 param 타입은 const char*가 되어서 const 문자열을 가리키는 수정 가능한 포인터가 된다.배열 인수const char name[] = &quot;J. P. Briggs&quot;  // name의 타입은 const char[13]const char* ptrToName = name        // 배열이 포인터로 붕괴된다.template&lt;typename T&gt;void f(T param);    // 값 전달 매개변수가 있는 템플릿f(name);템플릿 함수에 값으로 전달되는 배열의 형식은 포인터로 추론된다. 즉 T는 const char*로 추론된다.함수의 매개변수를 배열로 선언 할 수는 없지만, 배열에 대한 참조로 선언할 수는 있다.template&lt;typename T&gt;void f(T&amp; param);     // 참조 전달 매개변수가 있는 템플릿f(name);              // 배열을 f에 전달param타입을 바꿔서 호출하면 T에 대해 추론된 형식은 배열의 실제 형식이된다.이 예에서는 T는 const char [13]이 되고 param의 타입은 const char (&amp;)[13]이 된다.함수 인수void someFunc(int, double); // someFunc는 함수;                            // 형식은 void(int, double)template&lt;typename T&gt;void f1(T param);           // f1의 param은 값 전달 방식template&lt;typename T&gt;void f1(T&amp; param);          // f2의 param은 값 전달 방식f1(someFunc);               // param은 함수 포인터로 추론됨                            // 형식은 void(*)(int, double)f2(someFunc);               // param은 함수 참조로 추론됨                            // 형식은 void (&amp;)(int, double)결론  템플릿 타입 추론 도중 참조 형식의 인수들은 참조성이 무시된다.  Universal Reference에 대한 타입 추론 과정에서 왼값 인수들은 특별하게 취급된다.  값 전달 방식의 매개변수에 대한 타입 추론 과정에서 const 또는 volatile은 제거된다.  타입 추론 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다.단, 인수가 초기화하는 데 쓰이는 경우에는 포인터로 붕괴 하지 않는다.">
    <meta itemprop="datePublished" content="March 01, 2021">
    

    <div class="page__inner-wrap">
      
        <header>
          <h1 id="page-title" class="page__title" itemprop="headline">[Modern Effective C++] 1. 템플릿 타입 추론 규칙을 숙지
</h1>
          
            <p class="page__date"><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated: <time datetime="2021-03-01T00:00:00+00:00">March 01, 2021</time></p>
          
        </header>
      

      <section class="page__content" itemprop="text">
        
          <aside class="sidebar__right sticky">
            <nav class="toc">
              
                <header><h4 class="nav__title"><i class="fas fa-file-alt"></i> On this page</h4></header>
                <ul class="toc__menu"><li><a href="#템플릿-추론-방식">템플릿 추론 방식</a><ul><li><a href="#1-paramtype이-포인터-또는-참조-형식이지만-universal-reference는-아닌-경우">1. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우</a></li><li><a href="#2-paramtype이-universal-reference인-경우">2. ParamType이 Universal Reference인 경우</a></li><li><a href="#3-paramtype이-포인터도-아니고-참조도-아닌-경우">3. ParamType이 포인터도 아니고 참조도 아닌 경우</a></li></ul></li><li><a href="#배열-인수">배열 인수</a></li><li><a href="#함수-인수">함수 인수</a></li><li><a href="#결론">결론</a></li></ul>

              
            </nav>
            <!-- devinlife comment : right-sidebar ads -->
            <nav class="toc-custom">
              
            </nav>
          </aside>
        
        <div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">ParamType</span> <span class="n">param</span><span class="p">);</span>
<span class="n">f</span><span class="p">(</span><span class="n">expr</span><span class="p">);</span>
</code></pre></div></div>

<p>위와같은 템플릿 함수를 호출할때 컴파일러는 expr을 이용해 T 와 ParamType을 추론한다.</p>

<blockquote>
  <p>T에대해 추론된 형식은 항상 expr의 형식이 되지 않는다. expr의 형식외에도 ParamType의 형태에도 의존하기 때문. ParamType형태에 따라 세 가지 경우로 나뉜다.</p>
</blockquote>

<ul>
  <li>
    <p>ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우</p>
  </li>
  <li>
    <p>ParamType이 Universal Reference인 경우</p>
  </li>
  <li>
    <p>ParamType이 포인터도 아니고 참조도 아닌 경우</p>
  </li>
</ul>

<h1 id="템플릿-추론-방식">템플릿 추론 방식</h1>

<h2 id="1-paramtype이-포인터-또는-참조-형식이지만-universal-reference는-아닌-경우">1. ParamType이 포인터 또는 참조 형식이지만 Universal Reference는 아닌 경우</h2>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>   <span class="c1">// param은 참조 형식</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span>          <span class="c1">// int</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// const int</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// const int&amp;</span>

<span class="c1">//위의 변수들로 f 호출결과</span>
<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>               <span class="c1">// T는 int, param은 int&amp;</span>
<span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>              <span class="c1">// T는 const int, param은 const int&amp;</span>
<span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>              <span class="c1">// T는 const int, param은 const int&amp;</span>
</code></pre></div></div>

<p>이를 통해 알수있는것은</p>

<ul>
  <li>객체의 const성은 T에 대해 추론된 타입의 일부가 된다.</li>
  <li>타입 추론 과정에서 참조성은 무시가된다.</li>
</ul>

<h2 id="2-paramtype이-universal-reference인-경우">2. ParamType이 Universal Reference인 경우</h2>

<p>템플릿이 Universal Reference 매개변수를 받는 경우에 매개변수의 선언은 오른값 참조와 같은 모습이지만, 왼값 인수가 전달되면 다른 방식으로 행동한다.</p>

<!-- TODO 24 Universal Reference 추가 -->
<!-- TODO 28 Universal Reference 추가 -->

<ul>
  <li>expr이 왼값이면, T 와 ParamType 둘 다 왼값 참조로 추론된다.</li>
  <li>expr이 오른값이면, 1번과같이 ‘정상적인’ 규칙들이 적용</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span> <span class="n">param</span><span class="p">);</span>      <span class="c1">// param은 Universal Reference</span>

<span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>             <span class="c1">// 이전과 동일</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span>        <span class="c1">// 이전과 동일</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span>       <span class="c1">// 이전과 동일</span>

<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                   <span class="c1">// x는 왼값 T와 param의 형식 모두 int&amp;</span>
<span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                  <span class="c1">// cx는 왼값 T와 param의 형식 모두 const int&amp;</span>
<span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                  <span class="c1">// rx는 왼값 T와 param의 형식 모두 const int&amp;</span>

<span class="n">f</span><span class="p">(</span><span class="mi">27</span><span class="p">);</span>                  <span class="c1">// 27은 오른값 T는 int, param 타입은 int&amp;&amp;</span>
</code></pre></div></div>

<blockquote>
  <p>Universal Reference가 관여하면 왼값 인수와 오른값 인수에 대해 서로 다른 타입추론이 적용된다.</p>
</blockquote>

<h2 id="3-paramtype이-포인터도-아니고-참조도-아닌-경우">3. ParamType이 포인터도 아니고 참조도 아닌 경우</h2>

<p>인수가 값으로 전달되는 경우다.</p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>
</code></pre></div></div>

<p>param은 인수의 복사본으로 새로운 객체이다. 따라서 expr에서 T가 추론되는 과정에서 다음 규칙들이 적용된다.</p>

<ul>
  <li>expr이 참조형식이면, 이전처럼 참조 부분은 무시된다.</li>
  <li>expr이 참조를 무시하고, expr이 const이면 그 const 역시 무시한다. volatile역시 무시된다.</li>
</ul>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="mi">27</span><span class="p">;</span>             <span class="c1">// 이전과 동일</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">cx</span> <span class="o">=</span> <span class="n">x</span>        <span class="c1">// 이전과 동일</span>
<span class="k">const</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">rx</span> <span class="o">=</span> <span class="n">x</span>       <span class="c1">// 이전과 동일</span>

<span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>                   <span class="c1">// T와 param의 형식 모두 int</span>
<span class="n">f</span><span class="p">(</span><span class="n">cx</span><span class="p">);</span>                  <span class="c1">// T와 param의 형식 모두 int</span>
<span class="n">f</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>                  <span class="c1">// T와 param의 형식 모두 int</span>
</code></pre></div></div>

<blockquote>
  <p>param은 cx나 rx의 복사본이므로, const가 아니게된다.</p>
</blockquote>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="k">const</span> <span class="n">ptr</span> <span class="o">=</span>  <span class="c1">// ptr은 const 객체를 가리키는 const 포인터</span>
  <span class="s">"Fun with pointers"</span>

<span class="n">f</span><span class="p">(</span><span class="n">ptr</span><span class="p">);</span>
</code></pre></div></div>

<p>ptr은 다른 변수의 주소값을 가리키도록 변경할 수 없으며, 문자열 또한 변경이 불가능하다.<br />
ptr을 f에 전달하면 <strong>포인터 자체는 값으로 전달</strong>된다. 그래서 값 전달 방식의 타입추론과 같은 규칙으로 적용된다.<br />
결과적으로 param 타입은 const char*가 되어서 const 문자열을 가리키는 수정 가능한 포인터가 된다.</p>

<h1 id="배열-인수">배열 인수</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="kt">char</span> <span class="n">name</span><span class="p">[]</span> <span class="o">=</span> <span class="s">"J. P. Briggs"</span>  <span class="c1">// name의 타입은 const char[13]</span>
<span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">ptrToName</span> <span class="o">=</span> <span class="n">name</span>        <span class="c1">// 배열이 포인터로 붕괴된다.</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>    <span class="c1">// 값 전달 매개변수가 있는 템플릿</span>
<span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>
</code></pre></div></div>

<p>템플릿 함수에 값으로 전달되는 배열의 형식은 포인터로 추론된다. 즉 T는 const char*로 추론된다.<br />
함수의 매개변수를 배열로 선언 할 수는 없지만, <strong><em>배열에 대한 참조로 선언할 수는 있다.</em></strong></p>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>     <span class="c1">// 참조 전달 매개변수가 있는 템플릿</span>
<span class="n">f</span><span class="p">(</span><span class="n">name</span><span class="p">);</span>              <span class="c1">// 배열을 f에 전달</span>
</code></pre></div></div>

<p>param타입을 바꿔서 호출하면 T에 대해 추론된 형식은 배열의 실제 형식이된다.<br />
이 예에서는 T는 const char [13]이 되고 param의 타입은 const char (&amp;)[13]이 된다.</p>

<h1 id="함수-인수">함수 인수</h1>

<div class="language-cpp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">someFunc</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="p">);</span> <span class="c1">// someFunc는 함수;</span>
                            <span class="c1">// 형식은 void(int, double)</span>
<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">T</span> <span class="n">param</span><span class="p">);</span>           <span class="c1">// f1의 param은 값 전달 방식</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="nc">T</span><span class="p">&gt;</span>
<span class="kt">void</span> <span class="nf">f1</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span> <span class="n">param</span><span class="p">);</span>          <span class="c1">// f2의 param은 값 전달 방식</span>

<span class="n">f1</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>               <span class="c1">// param은 함수 포인터로 추론됨</span>
                            <span class="c1">// 형식은 void(*)(int, double)</span>

<span class="n">f2</span><span class="p">(</span><span class="n">someFunc</span><span class="p">);</span>               <span class="c1">// param은 함수 참조로 추론됨</span>
                            <span class="c1">// 형식은 void (&amp;)(int, double)</span>
</code></pre></div></div>

<h1 id="결론">결론</h1>

<ul>
  <li>템플릿 타입 추론 도중 참조 형식의 인수들은 참조성이 무시된다.
<!-- TODO 24연결 --></li>
  <li>Universal Reference에 대한 타입 추론 과정에서 왼값 인수들은 특별하게 취급된다.</li>
  <li>값 전달 방식의 매개변수에 대한 타입 추론 과정에서 const 또는 volatile은 제거된다.</li>
  <li>타입 추론 과정에서 배열이나 함수 이름에 해당하는 인수는 포인터로 붕괴한다.<br />
단, 인수가 초기화하는 데 쓰이는 경우에는 포인터로 붕괴 하지 않는다.</li>
</ul>

        
      </section>

      <footer class="page__meta">
        
        
  


  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-tags" aria-hidden="true"></i> Tags: </strong>
    <span itemprop="keywords">
    
      <a href="/tags/#c" class="page__taxonomy-item" rel="tag">C++</a><span class="sep">, </span>
    
      <a href="/tags/#modern-c" class="page__taxonomy-item" rel="tag">Modern C++</a><span class="sep">, </span>
    
      <a href="/tags/#modern-effective-c" class="page__taxonomy-item" rel="tag">Modern Effective C++</a><span class="sep">, </span>
    
      <a href="/tags/#type-deduction" class="page__taxonomy-item" rel="tag">Type Deduction</a>
    
    </span>
  </p>




  

  
  
  

  <p class="page__taxonomy">
    <strong><i class="fas fa-fw fa-folder-open" aria-hidden="true"></i> Categories: </strong>
    <span itemprop="keywords">
    
      
      
      <a href="/categories/#book" class="page__taxonomy-item" rel="tag">Book</a>
    
    </span>
  </p>


        
          <p class="page__date"><strong><i class="fas fa-fw fa-calendar-alt" aria-hidden="true"></i> Updated:</strong> <time datetime="2021-03-01T00:00:00+00:00">March 01, 2021</time></p>
        
      </footer>

      <section class="page__share">
  
    <h4 class="page__share-title">Share on</h4>
  

  <a href="https://twitter.com/intent/tweet?text=%5BModern+Effective+C%2B%2B%5D+1.+%ED%85%9C%ED%94%8C%EB%A6%BF+%ED%83%80%EC%9E%85+%EC%B6%94%EB%A1%A0+%EA%B7%9C%EC%B9%99%EC%9D%84+%EC%88%99%EC%A7%80%20https%3A%2F%2Ftonnac.github.io%2Fbook%2F01%2F" class="btn btn--twitter" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Twitter"><i class="fab fa-fw fa-twitter" aria-hidden="true"></i><span> Twitter</span></a>

  <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftonnac.github.io%2Fbook%2F01%2F" class="btn btn--facebook" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on Facebook"><i class="fab fa-fw fa-facebook" aria-hidden="true"></i><span> Facebook</span></a>

  <a href="https://www.linkedin.com/shareArticle?mini=true&url=https%3A%2F%2Ftonnac.github.io%2Fbook%2F01%2F" class="btn btn--linkedin" onclick="window.open(this.href, 'window', 'left=20,top=20,width=500,height=500,toolbar=1,resizable=0'); return false;" title="Share on LinkedIn"><i class="fab fa-fw fa-linkedin" aria-hidden="true"></i><span> LinkedIn</span></a>
</section>


      
  <nav class="pagination">
    
      <a href="/project/ue4/UE4.Wow/" class="pagination--pager" title="[UE4] UE4를 이용한 WoW모작
">Previous</a>
    
    
      <a href="/book/02/" class="pagination--pager" title="[Modern Effective C++] 2. auto의 타입 추론 규칙을 숙지
">Next</a>
    
  </nav>

    </div>

    
  </article>

  
  
    <div class="page__related">
      <h4 class="page__related-title">You may also enjoy</h4>
      <div class="grid__wrapper">
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
      <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> 2021.05.19</p>
      
      
        <a href="/project/ue4/ci/drafts_UE4_Jenkins_Android/" rel="permalink">[UE4] Jenkins 안드로이드 빌드
</a>
      
    </h2>
      <!--Archive page 용-: (post -> page)-->
<!--page__taxonomy.html에서 가져 옴--><span class="page__taxonomy">
            <span itemprop="keywords">
                <div class = "catecate"><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">Project</a><span class="sep"> </span><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">UE4</a><span class="sep"> </span><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">CI</a></div>
                <div>
                
                    <a href="/tags/" class="page__taxonomy-item-tag" rel="tag">Jenkins</a>
                
                </div>
            </span>
        </span>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
      <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> 2021.05.16</p>
      
      
        <a href="/project/ue4/ci/UE4_Jenkins/" rel="permalink">[UE4] Jenkins를 이용한 CI환경 구축
</a>
      
    </h2>
      <!--Archive page 용-: (post -> page)-->
<!--page__taxonomy.html에서 가져 옴--><span class="page__taxonomy">
            <span itemprop="keywords">
                <div class = "catecate"><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">Project</a><span class="sep"> </span><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">UE4</a><span class="sep"> </span><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">CI</a></div>
                <div>
                
                    <a href="/tags/" class="page__taxonomy-item-tag" rel="tag">Jenkins</a>
                
                </div>
            </span>
        </span>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
      <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> 2021.03.01</p>
      
      
        <a href="/book/02/" rel="permalink">[Modern Effective C++] 2. auto의 타입 추론 규칙을 숙지
</a>
      
    </h2>
      <!--Archive page 용-: (post -> page)-->
<!--page__taxonomy.html에서 가져 옴--><span class="page__taxonomy">
            <span itemprop="keywords">
                <div class = "catecate"><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">Book</a></div>
                <div>
                
                    <a href="/tags/" class="page__taxonomy-item-tag" rel="tag">Modern Effective C++</a><span class="sep"> </span>
                
                    <a href="/tags/" class="page__taxonomy-item-tag" rel="tag">C++</a><span class="sep"> </span>
                
                    <a href="/tags/" class="page__taxonomy-item-tag" rel="tag">Modern C++</a><span class="sep"> </span>
                
                    <a href="/tags/" class="page__taxonomy-item-tag" rel="tag">Type Deduction</a>
                
                </div>
            </span>
        </span>
  </article>
</div>
        
          



<div class="grid__item">
  <article class="archive__item" itemscope itemtype="https://schema.org/CreativeWork">
    
    <h2 class="archive__item-title" itemprop="headline">
      
      <p class="page__meta"><i class="far fa-fw fa-calendar-alt" aria-hidden="true"></i> 2021.02.14</p>
      
      
        <a href="/project/ue4/UE4.Wow/" rel="permalink">[UE4] UE4를 이용한 WoW모작
</a>
      
    </h2>
      <!--Archive page 용-: (post -> page)-->
<!--page__taxonomy.html에서 가져 옴--><span class="page__taxonomy">
            <span itemprop="keywords">
                <div class = "catecate"><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">Project</a><span class="sep"> </span><a href="/categories/#book" class="page__taxonomy-item-category" rel="tag">UE4</a></div>
                <div>
                
                    <a href="/tags/" class="page__taxonomy-item-tag" rel="tag">Wow</a>
                
                </div>
            </span>
        </span>
  </article>
</div>
        
      </div>
    </div>
  
  
</div>
    </div>

    

    <div id="footer" class="page__footer">
      <footer>
        <!-- start custom footer snippets -->

<!-- end custom footer snippets -->
        <div class="page__footer-follow">
  <ul class="social-icons">
    
      <li><strong>Follow:</strong></li>
    

    
      
        
      
        
      
        
      
        
      
        
      
        
      
    

    
      <li><a href="/feed.xml"><i class="fas fa-fw fa-rss-square" aria-hidden="true"></i> Feed</a></li>
    
  </ul>
</div>

<div class="page__footer-copyright">&copy; 2021 tonnac. Powered by <a href="https://jekyllrb.com" rel="nofollow">Jekyll</a> &amp; <a href="https://mademistakes.com/work/minimal-mistakes-jekyll-theme/" rel="nofollow">Minimal Mistakes</a>.</div>

      </footer>
    </div>

    
  <script src="/assets/js/main.min.js"></script>










  </body>
</html>
